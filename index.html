<!DOCTYPE html>
<html lang="en">

<head>
	<script src="https://d3js.org/d3.v4.min.js"></script>
	<script src="https://d3js.org/d3-hsv.v0.1.min.js"></script>
	<script src="https://d3js.org/d3-contour.v1.min.js"></script>
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
	<script src="outliersFilter.js"></script>
	<script src="simplify-edited.js"></script>
	<script src="underscore.js"></script>
	<script src="syntheticDataSimplifier.js"></script>
	<meta charset="utf-8">
	<style>
		#svg1 {
			position: relative;
			top: 10px;
			left: 300px;
			isolation: isolate;
			visibility: hidden;
		}

		/* #svg2 {
			left: 10px;
			isolation: isolate;
		} */

		/* #svg2 {
			left: 472px;
			isolation: isolate;
		}

		#svg3 {
			left: 934px;
			isolation: isolate;
		} */

		.sidebysideSVG {
			position: relative;
			top: 200px;
			left: 14px;
			isolation: isolate;
			visibility: hidden;
		}

		div {
			isolation: isolate;
		}

		/* path{
			mix-blend-mode: multiply;
		} */

		#divlogo {
			float: left;
			height: 60px;
			width: 14%;
			background-color: #dddddd;
			/* padding-top: 5px; */
			/* padding-right: 0px; */
			margin: 0px;
			background-image: url('background/usask logo.png');
			background-size: contain;
		}

		#divtop {
			float: left;
			height: 60px;
			width: 86%;
			background-color: #dddddd;
			/* padding-top: 5px; */
			/* padding-right: 0px; */
			margin: 0px;
		}

		#divmenu {
			float: left;
			margin-top: 0px;
			height: 40px;
			width: 100%;
			/* background-color: #787878; */
			background-color: white;
		}

		/* .buttonDesigns{
			margin-top: 4px;
			margin-left: 120px;
		} */

		#showPL {
			margin-left: 200px;
		}

		.buttonSubmit {
			background-color: #4CAF50;
			/* Green */
			border: none;
			color: white;
			padding: 10px 20px;
			text-align: center;
			text-decoration: none;
			display: inline-block;
			font-size: 16px;
			margin-left: 150px;
			transition-duration: 0.4s;
			cursor: pointer;
		}

		.buttonSubmit {
			background-color: white;
			color: black;
			border: 2px solid #4CAF50;
		}

		.buttonSubmit:hover {
			background-color: #4CAF50;
			color: white;
		}

		.buttonDesigns {
			display: inline-block;
			width: 200px;
			margin-top: 5px;
			padding: 5px 15px;
			font-size: 15px;
			cursor: pointer;
			text-align: center;
			text-decoration: none;
			outline: none;
			/* color: #fff; */
			color: black;
			/* background-color: #4CAF50; */
			background-color: #dddddd;
			border: none;
			border-radius: 10px;
			box-shadow: 0 5px #999;
		}

		.buttonDesigns:hover {
			/* background-color: #3e8e41 */
			background-color: #c4c4c4
		}

		.buttonDesigns:active {
			/* background-color: #3e8e41; */
			background-color: #c4c4c4
			box-shadow: 0 3px #666;
			transform: translateY(4px);
		}

		#divbody {
			float: left;
			margin-top: 0px;
			height: 820px;
			width: 1420px;
			/* background-color: #aaaaaa; */
			background-color: #d3d3d3;
			/* border-style: double;
			border-color: black;
			border: 2px; */
		}

		#divControl {
			float: left;
			margin-left: 2px;
			height: 620px;
			width: 463px;
			padding-left: 2px;
			/* background-color: #5a5a5a; */
			/* background-color: #d1d1d1; */
			/* background-color: #838383; */
			background-color: #b6b6b6;
		}

		option {
	 /* background-color: #74d3b0; */
	 background-color: #c4c4c4;
	 }

		#parameterControlFrom {
			margin-left: 20px;
			font-size: 18px;
		}

		.parameterControlHeadline{
			padding: 0px 10px;
		}

		/* #outputClass {
			margin-left: 20px;
			font-size: 18px;
			color: red;
		} */

		#divOutput {
			float: left;
			margin-left: 2px;
			margin-top: 2px;
			height: 198px;
			width: 465px;
			/* background-color: #5a5a5a; */
			/* background-color: #d1d1d1; */
			/* background-color: #656565; */
			background-color: #a2a2a2;
		}

		#divbottom {
			margin-top: 2px;
			float: left;
			height: 30px;
			width: 100%;
			/* background-color: #5a5a5a; */
			background-color: #dddddd;
				/* background-color: #3d3d3d; */
		}
	</style>

	<script>
		$(document).ready(function() {
			changeFormInput();
			$("#showPL").click(function() {
				designCurrent = 1;
				$("#svg1").empty();
				$("#svg1").show();
				$(".sidebysideSVG").css("visibility", "hidden");
				$("#svg1").css("visibility", "visible");
				addBackground();
				visualize();
			});
			$("#showCB").click(function() {
				designCurrent = 2;
				$("#svg1").empty();
				$("#svg1").show();
				$(".sidebysideSVG").css("visibility", "hidden");
				$("#svg1").css("visibility", "visible");
				addBackground();
				visualize();
			});
			$("#showPie").click(function() {
				designCurrent = 3;
				$("#svg1").empty();
				$("#svg1").show();
				$(".sidebysideSVG").css("visibility", "hidden");
				$("#svg1").css("visibility", "visible");
				addBackground();
				visualize();
			});
			$("#showTS").click(function() {
				designCurrent = 4;
				$("#svg1").empty();
				$("#svg1").show();
				$(".sidebysideSVG").css("visibility", "hidden");
				$("#svg1").css("visibility", "visible");
				addBackground();
				visualize();
			});
			$("#showSidebySide").click(function() {
				designCurrent = 5;
				$(".sidebysideSVG").empty();
				$("#svg1").hide();
				$(".sidebysideSVG").css("visibility", "visible");
				addBackground();
				visualize();
			});
		});
	</script>
</head>

<body>
	<div id="divlogo">
	</div>
	<div id="divtop">
		<h3 style="text-align:right;font-size:30px;color:black;padding-right:20px;padding-top:10px; margin-bottom: 0px;margin: 0px">Contour Lines for Multivariate Data Visualization</h3>
	</div>
	<div id="divmenu">
		<button id="showPL" class="buttonDesigns" style="font-weight:bold;">Parallel Lines</button>
		<button id="showCB" class="buttonDesigns" style="font-weight:bold;">Color Blending</button>
		<button id="showPie" class="buttonDesigns" style="font-weight:bold;">Pie</button>
		<button id="showTS" class="buttonDesigns" style="font-weight:bold;">Thickness-Shade</button>
		<button id="showSidebySide" class="buttonDesigns" style="font-weight:bold;">Side-by-Side</button>
		<!-- <h3 style="text-align:right;font-size:20px;color:white;margin: 0px;">Contour Lines for Multivariate Visualization</h3> -->
	</div>
	<div id="divbody">
		<svg x="200" y="200" width="800" height="800" stroke="#fff" stroke-width="0.5" id="svg1">
			<!-- <rect id="bigrect" x="0" y="0" width="560" height="200" style="fill:#3d3d3d ;stroke:gray;opacity:1" /> -->
			<!-- <image href="background/papertop back.PNG" style="opacity:1; height: 800px; width: 800px" /> -->
		</svg>
		<svg width="462" height="462" stroke="#fff" stroke-width="0.5" id="svg2" class="sidebysideSVG">
			<!-- <rect id="bigrect" x="0" y="0" width="1560" height="1200" style="fill:#3d3d3d ;stroke:gray;opacity:1" /> -->
			<!-- <image href="background/papertop back.PNG" style="opacity:1; height: 462px; width: 462px" /> -->
		</svg>
		<svg width="462" height="462" stroke="#fff" stroke-width="0.5" id="svg3" class="sidebysideSVG">
			<!-- <rect id="bigrect" x="0" y="0" width="1560" height="1200" style="fill:#3d3d3d ;stroke:gray;opacity:1" /> -->
			<!-- <image href="background/papertop back.PNG" style="opacity:1; height: 462px; width: 462px" /> -->
		</svg>
		<svg width="462" height="462" stroke="#fff" stroke-width="0.5" id="svg4" class="sidebysideSVG">
			<!-- <rect id="bigrect" x="0" y="0" width="1560" height="1200" style="fill:#3d3d3d ;stroke:gray;opacity:1" /> -->
			<!-- <image href="background/papertop back.PNG" style="opacity:1; height: 462px; width: 462px" /> -->
		</svg>
	</div>
	<div id="divControl">
		<!-- <h3 id="parameterControlHeadline" style="text-align:center;font-size:20px;color:#00ffff ;">Step 1: Select the dataset and the design parameters</h3>
		<h3 id="parameterControlHeadline2" style="text-align:center;font-size:20px;color:#00ffff;">Step 2: Select a design to visualize the chosen data</h3> -->
		<h2 class="parameterControlHeadline">Step 1:</h2>
		<h3 class="parameterControlHeadline" style="font-size:20px;">Select the dataset, the number of contour intervals, and the contour line width from below</h3>
		<h2 class="parameterControlHeadline">Step 2:</h2>
		<h3 class="parameterControlHeadline" style="font-size:20px;">Select one of the five designs from the top to visualize the chosen data combination</h3>
		<br><br><br>
		<form name="form1" id="parameterControlFrom" onchange="changeFormInput()">
			Dataset: <select name="datasetForm" id="datasetForm">
				<option value="" >Select dataset</option>
				<option value="synthetic1" selected>Synthetic Dataset 1</option>
				<option value="synthetic2">Synthetic Dataset 2</option>
				<option value="real1">Real-Life Dataset 1</option>
				<option value="real2">Real-Life Dataset 2</option>
			</select>
			<br><br>
			Contour Interval: <select name="intervalForm" id="intervalForm">
				<option value="" >Please select the number of contour intervals</option>
				<option value="4" selected> 4 </option>
				<option value="6" > 6 </option>
				<option value="8" > 8 </option>
			</select>
			<br><br>
			Contour Line Width: <select name="lineWidthForm" id="lineWidthForm">
				<option value="" >Please select the contour line width</option>
				<option value="1" selected> 1 </option>
				<option value="2"> 2 </option>
				<option value="3"> 3 </option>
				<option value="4" > 4 </option>
				<option value="5"> 5 </option>
				<option value="6"> 6 </option>
				<option value="7"> 7 </option>
				<option value="8"> 8 </option>
				<option value="9"> 9 </option>
				<option value="10"> 10 </option>
				<option value="11"> 11 </option>
				<option value="12"> 12 </option>
			</select>
			<br><br>
			<br><br>
			<!-- <input type="button" value="Submit" class="buttonSubmit"> -->
			<!-- <button id="buttonSubmit" class="buttonSubmit">Submit</button> -->
		</form>
	</div>
	<div id="divOutput">
		<h3 class="outputClass" style="color:black;">&nbsp&nbsp Cursor Position (X,Y)</h3>
		<p id="mousePosition" class="outputClass" style="color:black;font-size:20px;">&nbsp&nbsp   X: ---  &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp   Y: ---   </p>
		<h3 class="outputClass" style="color:black;">&nbsp&nbsp Contour Band Value at the Cursor Position</h3>
		<p id="contourPosition" class="outputClass" style="color:black;font-size:20px;">&nbsp&nbsp  A: --- &nbsp&nbsp&nbsp&nbsp B: --- &nbsp&nbsp&nbsp&nbsp C: --- &nbsp&nbsp&nbsp&nbsp D: ---</p>
	</div>
	<div id="divbottom">
		<p style="text-align:left;font-size:18px;color:black;padding-left:20px;padding-top:5px; margin-bottom: 0px;margin: 0px">Developed by - Gazi Hasnat &nbsp&nbsp || &nbsp&nbsp
			MSc Student, Dept of CS &nbsp&nbsp || &nbsp&nbsp VGA Lab, USask &nbsp&nbsp || &nbsp&nbsp Interaction Lab, USask &nbsp&nbsp || &nbsp&nbsp 2020</p>
	</div>

	<script>
		window.changeFormInput = function() {
			if (document.getElementById("datasetForm").value == "" || document.getElementById("intervalForm").value == "" || document.getElementById("lineWidthForm").value == "") {
				// console.log("Syn Data chosen");
				// document.getElementsByClassName("buttonDesigns").style.cursor = "not-allowed";
				// document.getElementsByClassName("buttonDesigns").style.opacity = 0.5;
				// document.getElementsByClassName("buttonDesigns").disabled = true;
				document.getElementById("showPL").style.cursor = "not-allowed";
				document.getElementById("showPL").style.opacity = 0.5;
				document.getElementById("showPL").disabled = true;
				document.getElementById("showCB").style.cursor = "not-allowed";
				document.getElementById("showCB").style.opacity = 0.5;
				document.getElementById("showCB").disabled = true;
				document.getElementById("showPie").style.cursor = "not-allowed";
				document.getElementById("showPie").style.opacity = 0.5;
				document.getElementById("showPie").disabled = true;
				document.getElementById("showTS").style.cursor = "not-allowed";
				document.getElementById("showTS").style.opacity = 0.5;
				document.getElementById("showTS").disabled = true;
				document.getElementById("showSidebySide").style.cursor = "not-allowed";
				document.getElementById("showSidebySide").style.opacity = 0.5;
				document.getElementById("showSidebySide").disabled = true;
			}
			else if (document.getElementById("datasetForm").value != "" && document.getElementById("intervalForm").value != "" && document.getElementById("lineWidthForm").value != "") {
				document.getElementById("showPL").style.cursor = "pointer";
				document.getElementById("showPL").style.opacity = 1;
				document.getElementById("showPL").disabled = false;
				document.getElementById("showCB").style.cursor = "pointer";
				document.getElementById("showCB").style.opacity = 1;
				document.getElementById("showCB").disabled = false;
				document.getElementById("showPie").style.cursor = "pointer";
				document.getElementById("showPie").style.opacity = 1;
				document.getElementById("showPie").disabled = false;
				document.getElementById("showTS").style.cursor = "pointer";
				document.getElementById("showTS").style.opacity = 1;
				document.getElementById("showTS").disabled = false;
				document.getElementById("showSidebySide").style.cursor = "pointer";
				document.getElementById("showSidebySide").style.opacity = 1;
				document.getElementById("showSidebySide").disabled = false;

				thickness = document.getElementById("lineWidthForm").value;
				thickness = parseInt(thickness);
				interval = document.getElementById("intervalForm").value;
				interval = parseInt(interval);
				if (document.getElementById("datasetForm").value == "synthetic1") {
					if (interval == 4) {
						jsonfilename = "Data/controlledData-ApBmCmDm4Cluster3contour12overlap.json";
					} else if (interval == 6) {
						jsonfilename = "Data/controlledData-ApBmCmDm4Cluster5contour12overlap.json";
					} else if (interval == 8) {
						jsonfilename = "Data/controlledData-ApBmCmDm4Cluster7contour12overlap.json";
					}
				} else if (document.getElementById("datasetForm").value == "synthetic2") {
					if (interval == 4) {
						jsonfilename = "Data/controlledData-ApBmCmDm4Cluster3contour12overlap2.json";
					} else if (interval == 6) {
						jsonfilename = "Data/controlledData-ApBmCmDm4Cluster5contour12overlap2.json";
					} else if (interval == 8) {
						jsonfilename = "Data/controlledData-ApBmCmDm4Cluster7contour12overlap2.json";
					}
				} else if (document.getElementById("datasetForm").value == "real1") {
					jsonfilename = "Data/real-paper top custom120.json";
				} else if (document.getElementById("datasetForm").value == "real2") {
					jsonfilename = "Data/real-customized.json";
				}

			}
		}

		// startTime = new Date();
		designCurrent = 0;
		// function zoomFunction(){
		// 	d3.selectAll("path")
		// 	.attr("transform", "translate(" + d3.event.translate +
		// 	") scale (" + d3.event.scale + ")");
		// }
		//
		// var zoom = d3.zoom()
		// 							.scaleExtent([0.2,10])
		// 							.on("zoom", zoomFunction);
		var svg1 = d3.select("#svg1")
			// .attr("fill","grey")
			.on('mousemove', mouseEvent);
		// .call(zoom)
		var svg2 = d3.select("#svg2")
								.on('mousemove', mouseEventB);
		var svg3 = d3.select("#svg3")
								.on('mousemove', mouseEventC);
		var svg4 = d3.select("#svg4")
								.on('mousemove', mouseEventD);
		var svgwidth = +svg1.attr("width");
		var svgheight = +svg1.attr("height");
		thickness = 4;
		interval = 4;

		window.addBackground = function(){
			// add background map
			if(document.getElementById("datasetForm").value == "synthetic1" || document.getElementById("datasetForm").value == "synthetic2"){
				// add background map
				if(designCurrent != 5){
					let newElement = document.createElementNS('http://www.w3.org/2000/svg', 'image');
					newElement.setAttribute('href', 'background/backSynthetic.PNG');
					newElement.setAttribute('width', '800');
					newElement.setAttribute('height', '800');
					document.getElementById('svg1').appendChild(newElement.cloneNode(true));
				}
				else{
					let newElement = document.createElementNS('http://www.w3.org/2000/svg', 'image');
					newElement.setAttribute('href', 'background/backSynthetic.PNG');
					newElement.setAttribute('width', '462');
					newElement.setAttribute('height', '462');
					document.getElementById('svg2').appendChild(newElement.cloneNode(true));
					document.getElementById('svg3').appendChild(newElement.cloneNode(true));
					document.getElementById('svg4').appendChild(newElement.cloneNode(true));
				}
			}
			else if(document.getElementById("datasetForm").value == "real1"){
				// add background map
				if(designCurrent != 5){
					let newElement = document.createElementNS('http://www.w3.org/2000/svg', 'image');
					newElement.setAttribute('href', 'background/papertop back.PNG');
					newElement.setAttribute('width', '800');
					newElement.setAttribute('height', '800');
					newElement.setAttribute('opacity', '0.7');
					document.getElementById('svg1').appendChild(newElement.cloneNode(true));
				}
				else{
					let newElement = document.createElementNS('http://www.w3.org/2000/svg', 'image');
					newElement.setAttribute('href', 'background/papertop back.PNG');
					newElement.setAttribute('width', '462');
					newElement.setAttribute('height', '462');
					newElement.setAttribute('opacity', '0.7');
					document.getElementById('svg2').appendChild(newElement.cloneNode(true));
					document.getElementById('svg3').appendChild(newElement.cloneNode(true));
					document.getElementById('svg4').appendChild(newElement.cloneNode(true));
				}
			}
			else if(document.getElementById("datasetForm").value == "real2"){
				// add background map
				if(designCurrent != 5){
					let newElement = document.createElementNS('http://www.w3.org/2000/svg', 'image');
					newElement.setAttribute('href', 'background/back-real.PNG');
					newElement.setAttribute('width', '800');
					newElement.setAttribute('height', '800');
					newElement.setAttribute('opacity', '0.7');
					document.getElementById('svg1').appendChild(newElement.cloneNode(true));
				}
				else{
					let newElement = document.createElementNS('http://www.w3.org/2000/svg', 'image');
					newElement.setAttribute('href', 'background/back-real.PNG');
					newElement.setAttribute('width', '462');
					newElement.setAttribute('height', '462');
					newElement.setAttribute('opacity', '0.7');
					document.getElementById('svg2').appendChild(newElement.cloneNode(true));
					document.getElementById('svg3').appendChild(newElement.cloneNode(true));
					document.getElementById('svg4').appendChild(newElement.cloneNode(true));
				}
			}
		}

		// svg1.call(d3.zoom()
		// 					.scaleExtent([0,10])
		// 					.translateExtent([[0, 0], [svgwidth, svgheight]])
		// 						.on("zoom", function () {
		// 										var transform = d3.zoomTransform(this);
		// 			              svg1.attr("transform", "translate(" + transform.x + "," + transform.y + ") scale(" + transform.k + ")")
		// 			      }))
		// var svg6 = d3.select("#svg6")

		// jsonfilename = "";
		var jsonfilename = "Data/real-paper top custom120.json";

		window.visualize = function() {
			d3.json(jsonfilename, function(error, dataJSON) {
				if (error) throw error;

				points = 0;
				vWidth = dataJSON.width;
				vHeight = dataJSON.height;
				if(designCurrent != 5){
					mapRatio = +svg1.attr("width") / vWidth;
				}
				else {
					mapRatio = +svg2.attr("width") / vWidth;
				}

				latitude = vHeight;
				longitude = vWidth;
				// simplifyFactor=0;

				// data processing
				if(document.getElementById("datasetForm").value == "real1" || document.getElementById("datasetForm").value == "real2"){
					console.log('Actual TSK: ', dataJSON.TSK);
					filtered_TSK = filterOutliers(dataJSON.TSK)
					console.log('Filtered TSK: ', filtered_TSK);
					console.log('Actual SMOIS: ', dataJSON.SMOIS);
					filtered_SMOIS = filterOutliers(dataJSON.SMOIS);
					console.log('Filtered SMOIS: ', filtered_SMOIS);
					console.log('Actual PSFC: ', dataJSON.PSFC);
					filtered_PSFC = filterOutliers(dataJSON.PSFC)
					console.log('Filtered PSFC: ', filtered_PSFC);
					console.log('Actual ALBEDO: ', dataJSON.ALBEDO);
					filtered_ALBEDO = filterOutliers(dataJSON.ALBEDO)
					console.log('Filtered ALBEDO: ', filtered_ALBEDO);

					window.normalize = function(arr) {
						var result = arr.concat();
						max = d3.max(result);
						min = d3.min(result);
						for (i = 0; i < arr.length; i++) {
							result[i] = (result[i] - min) / (max - min);
						}
						return result;
					}

					normalized_TSK = normalize(filtered_TSK)
					console.log('Normalized TSK: ', normalized_TSK);
					normalized_SMOIS = normalize(filtered_SMOIS)
					console.log('Normalized SMOIS: ', normalized_SMOIS);
					normalized_PSFC = normalize(filtered_PSFC)
					console.log('Normalized PSFC: ', normalized_PSFC);
					normalized_ALBEDO = normalize(filtered_ALBEDO)
					console.log('Normalized ALBEDO: ', normalized_ALBEDO);

					dataJSON.TSK = normalized_TSK;
					dataJSON.SMOIS = normalized_SMOIS;
					dataJSON.PSFC = normalized_PSFC;
					dataJSON.ALBEDO = normalized_ALBEDO;

					window.meanMatrix = function(arr) {
						row = latitude;
						col = longitude;
						var meanmat = arr.concat();
						for (i = 2; i < row - 2; i++) {
							for (j = 2; j < col - 2; j++) {
								meanmat[i * latitude + j] = (arr[(i - 2) * latitude + (j - 2)] + arr[(i - 2) * latitude + (j - 1)] + arr[(i - 2) * latitude + j] + arr[(i - 2) * latitude + (j + 1)] + arr[(i - 2) * latitude + (j + 2)] +
									arr[(i - 1) * latitude + (j - 2)] + arr[(i - 1) * latitude + (j - 1)] + arr[(i - 1) * latitude + j] + arr[(i - 1) * latitude + (j + 1)] + arr[(i - 1) * latitude + (j + 2)] +
									arr[i * latitude + (j - 2)] + arr[i * latitude + (j - 1)] + arr[i * latitude + j] + arr[i * latitude + (j + 1)] + arr[i * latitude + (j + 2)] +
									arr[(i + 1) * latitude + (j - 2)] + arr[(i + 1) * latitude + (j - 1)] + arr[(i + 1) * latitude + j] + arr[(i + 1) * latitude + (j + 1)] + arr[(i + 1) * latitude + (j + 2)] +
									arr[(i + 2) * latitude + (j - 2)] + arr[(i + 2) * latitude + (j - 1)] + arr[(i + 2) * latitude + j] + arr[(i + 2) * latitude + (j + 1)] + arr[(i + 2) * latitude + (j + 2)]) / 25;

							}
						}
						return meanmat;
					}

					meanMatrix_TSK = meanMatrix(normalized_TSK);
					console.log('Mean Matrix TSK: ', meanMatrix_TSK);
					meanMatrix_SMOIS = meanMatrix(normalized_SMOIS);
					console.log('Mean Matrix SMOIS: ', meanMatrix_SMOIS);
					meanMatrix_PSFC = meanMatrix(normalized_PSFC);
					console.log('Mean Matrix PSFC: ', meanMatrix_PSFC);
					meanMatrix_ALBEDO = meanMatrix(normalized_ALBEDO);
					console.log('Mean Matrix ALBEDO: ', meanMatrix_ALBEDO);

					dataJSON.TSK = meanMatrix_TSK;
					dataJSON.SMOIS = meanMatrix_SMOIS;
					dataJSON.PSFC = meanMatrix_PSFC;
					dataJSON.ALBEDO = meanMatrix_ALBEDO;

					C = dataJSON.PSFC;
					D = dataJSON.TSK;
					B = dataJSON.SMOIS;
					A = dataJSON.ALBEDO;
				}
				else if(document.getElementById("datasetForm").value == "synthetic1" || document.getElementById("datasetForm").value == "synthetic2"){
					C = dataJSON.C;
					D = dataJSON.D;
					B = dataJSON.B;
					A = dataJSON.A;
				}

				window.getQuartileValue = function(arr, q) {
					ind = arr.length * q;
					if (ind - Math.floor(ind) == 0) {
						res = arr[Math.floor(ind) - 1];
						return parseFloat(res.toFixed(2));
					} else {
						k = Math.floor(ind) - 1;
						f = ind - Math.floor(ind);
						res = ((1 - f) * arr[k]) + (f * arr[k + 1]);
						return parseFloat(res.toFixed(2));
					}
				}

				window.getQuartiles = function(arr) {
					var values = arr.concat();
					// Then sort
					values.sort(function(a, b) {
						return a - b;
					});
					var q1 = getQuartileValue(values, .25);
					var q2 = getQuartileValue(values, .5);
					var q3 = getQuartileValue(values, .75);

					return [0, q1, q2, q3]
				}

				window.getQuartiles8 = function(arr) {
					var values = arr.concat();
					// Then sort
					values.sort(function(a, b) {
						return a - b;
					});
					var q1 = getQuartileValue(values, .125);
					var q2 = getQuartileValue(values, .25);
					var q3 = getQuartileValue(values, .375);
					var q4 = getQuartileValue(values, .5);
					var q5 = getQuartileValue(values, .675);
					var q6 = getQuartileValue(values, .75);
					var q7 = getQuartileValue(values, .85);

					return [0, q1, q2, q3, q4, q5, q6, q7]
				}

				// thresold choice
				if (interval == 4) {
					thresholds_A = [0, .25, .5, .75];
					thresholds_B = [0, .25, .5, .75];
					thresholds_C = [0, .25, .5, .75];
					thresholds_D = [0, .25, .5, .75];
				}
				else if (interval == 6) {
					thresholds_A = [0, .19, .38, .57, .76, .95];
					thresholds_B = [0, .19, .38, .57, .76, .95];
					thresholds_C = [0, .19, .38, .57, .76, .95];
					thresholds_D = [0, .19, .38, .57, .76, .95];
				}
				else if (interval == 8) {
					thresholds_A = [0, .125, .25, .375, .5, .625, .75, .875];
					thresholds_B = [0, .125, .25, .375, .5, .625, .75, .875];
					thresholds_C = [0, .125, .25, .375, .5, .625, .75, .875];
					thresholds_D = [0, .125, .25, .375, .5, .625, .75, .875];
				}

				console.log('A quartiles:', thresholds_A);
				console.log('B quartiles:', thresholds_B);
				console.log('C quartiles:', thresholds_C);
				console.log('D quartiles:', thresholds_D);

				contourOutput_A = d3.contours()
					.size([dataJSON.width, dataJSON.height])
					.thresholds(thresholds_A)
					(A)
				contourOutput_B = d3.contours()
					.size([dataJSON.width, dataJSON.height])
					.thresholds(thresholds_B)
					(B)
				contourOutput_C = d3.contours()
					.size([dataJSON.width, dataJSON.height])
					.thresholds(thresholds_C)
					(C)
				contourOutput_D = d3.contours()
					.size([dataJSON.width, dataJSON.height])
					.thresholds(thresholds_D)
					(D)

				console.log('The A contours are: ', contourOutput_A);
				console.log('The B contours are: ', contourOutput_B);
				console.log('The C contours are: ', contourOutput_C);
				console.log('The D contours are: ', contourOutput_D);

				// window.drawA = function() {
				// 	svg1.selectAll("path")
				// 		.data(contourOutput_A)
				// 		.enter().append("path")
				// 		.attr("d", d3.geoPath(d3.geoIdentity().scale(mapRatio)))
				// 		.attr("fill", function(d) {
				// 			return color(d.value);
				// 		})
				// 		// .attr("opacity", .5)
				// 		.attr("stroke", "black")
				// 		.attr("stroke-width", .5)
				// 	// .attr("stroke-opacity", .1);
				// };
				// // drawA();
				// window.drawB = function() {
				// 	svg1.selectAll("path")
				// 		.data(contourOutput_B)
				// 		.enter().append("path")
				// 		.attr("d", d3.geoPath(d3.geoIdentity().scale(mapRatio)))
				// 		.attr("fill", function(d) {
				// 			return color(d.value);
				// 		})
				// 		// .attr("opacity", .5)
				// 		.attr("stroke", "black")
				// 		.attr("stroke-width", .5)
				// 	// .attr("stroke-opacity", .1);
				// };
				// // drawB();
				// window.drawC = function() {
				// 	svg1.selectAll("path")
				// 		.data(contourOutput_C)
				// 		.enter().append("path")
				// 		.attr("d", d3.geoPath(d3.geoIdentity().scale(mapRatio)))
				// 		.attr("fill", function(d) {
				// 			return color(d.value)
				// 		})
				// 		// .attr("opacity", .5)
				// 		.attr("stroke", "black")
				// 		.attr("stroke-width", .5)
				// 	// .attr("stroke-opacity", .1);
				// };
				// // drawC();
				// window.drawD = function() {
				// 	svg1.selectAll("path")
				// 		.data(contourOutput_D)
				// 		.enter().append("path")
				// 		.attr("d", d3.geoPath(d3.geoIdentity().scale(mapRatio)))
				// 		// .attr("fill", "grey")
				// 		.attr("fill", function(d) {
				// 			return color(d.value)
				// 		})
				// 		// .attr("opacity", .5)
				// 		.attr("stroke", "black")
				// 		.attr("stroke-width", .5)
				// 	// .attr("opacity", .3);
				// };
				// // drawD();

				contourtoWorkon = contourOutput_A;

				window.inside = function(point, poly) {
					// ray-casting algorithm based on
					// http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html
					var x = point[0],
						y = point[1];
					var inside = false;
					for (var i = 0, j = poly.length - 1; i < poly.length; j = i++) {
						var xi = poly[i][0],
							yi = poly[i][1];
						var xj = poly[j][0],
							yj = poly[j][1];
						var intersect = ((yi > y) != (yj > y)) &&
							(x < (xj - xi) * (y - yi) / (yj - yi) + xi);
						if (intersect) inside = !inside;
					}
					return inside;
				};

				window.getContourLabel = function(xMouse, yMouse, contourOutput) {
					contourWithPointTreshold = 0;
					for (index = 0; index < contourOutput.length; index++) {
						for (i = 0; i < contourOutput[index].coordinates.length; i++) {
							// isInside = inside([xMouse/mapRatio,yMouse/mapRatio],contourOutput[index].coordinates[i][0]);
							isInside = inside([xMouse, yMouse], contourOutput[index].coordinates[i][0]);
							// IsCursorInContour(isInside,contourOutput_p[index]);
							if (isInside == true) {
								if (contourOutput[index].coordinates[i].length == 1) {
									// contour doesn't have holes in it
									contourWithPointTreshold = contourOutput[index].value;
								} else {
									//cotour has holes in it
									inHoleFlag = 0;
									for (j = 1; j < contourOutput[index].coordinates[i].length; j++) {
										// inHole = inside([xMouse/mapRatio,yMouse/mapRatio],contourOutput[index].coordinates[i][j]);
										inHole = inside([xMouse, yMouse], contourOutput[index].coordinates[i][j]);
										if (inHole == true) {
											// inside a hole, then check if it is in subsequent smaller threshold holes or not
											inHoleFlag++;
											for (k = index - 1; k >= 0; k--) {
												for (l = 0; l < contourOutput[k].coordinates.length; l++) {
													if (contourOutput[k].coordinates[l].length == 1) {
														continue;
													} else {
														for (m = 1; m < contourOutput[k].coordinates[l].length; m++) {
															// if (inside([xMouse/mapRatio,yMouse/mapRatio],contourOutput[k].coordinates[l][m]) == true){
															if (inside([xMouse, yMouse], contourOutput[k].coordinates[l][m]) == true) {
																// inside on more level inside
																inHoleFlag++;
															}
														}
													}
												}
											}
										}
									}
									contourWithPointTreshold = contourOutput[index - inHoleFlag].value;
								}
							}
						}
					}
					return contourWithPointTreshold;
				}

				// finalize colors according to interval and design
				if(designCurrent == 1 || designCurrent == 3){
					colorB = "#f44345"; colorC = "#4345f4"; colorD = "white";
				}
				else if(designCurrent == 2){
					if(interval == 4){
						colorB = d3.scaleLinear().domain([0, .25, .5, .75]).range(["#fffcfc", "#fcc5c5", "#f88d8e", "#f55657"]);
						colorC = d3.scaleLinear().domain([0, .25, .5, .75]).range(["#fcfcff", "#c5c5fc", "#8d8ef8", "#5657f5"]);
					}
					if(interval == 6){
						colorB = d3.scaleLinear().domain([0,0.19,0.38,0.57,0.76,0.95]).range(["#fffcfc", "#fdd7d8", "#fbb2b3","#f88d8e", "#f6686a", "#f44345"]);
						colorC = d3.scaleLinear().domain([0,0.19,0.38,0.57,0.76,0.95]).range(["#fcfcff", "#d7d8fd", "#b2b3fb", "#8d8ef8", "#686af6","#4345f4"]);
					}
					if(interval == 8){
						colorB = d3.scaleLinear().domain([0,.125,.25,.375,.5,.675,.75,.875]).range(["#fffcfc", "#fdd7d8", "#fbb2b3","#f88d8e", "#f6686a", "#f44345", "#f21e20", "#dc0d0f"]);
						colorC = d3.scaleLinear().domain([0,.125,.25,.375,.5,.675,.75,.875]).range([ "#fcfcff", "#d7d8fd", "#b2b3fb", "#8d8ef8", "#686af6","#4345f4", "#1e20f2", "#0d0fdc"]);
					}
				}
				else if(designCurrent == 4){
					colorD = "#f44345";
					if(interval == 4){
						colorC = d3.scaleLinear().domain([0, .25, .5, .75]).range(["#fcfcff", "#c5c5fc", "#8d8ef8", "#5657f5"]);
					}
					if(interval == 6){
						colorC = d3.scaleLinear().domain([0,0.19,0.38,0.57,0.76,0.95]).range(["#fcfcff", "#d7d8fd", "#b2b3fb", "#8d8ef8", "#686af6","#4345f4"]);
					}
					if(interval == 8){
						colorC = d3.scaleLinear().domain([0,.125,.25,.375,.5,.675,.75,.875]).range([ "#fcfcff", "#d7d8fd", "#b2b3fb", "#8d8ef8", "#686af6","#4345f4", "#1e20f2", "#0d0fdc"]);
					}
				}
				else if(designCurrent == 5){
					if(interval == 4){
						colorB = d3.scaleLinear().domain([0,.25,.5,.75]).range(["#fffcfc", "#fcc5c5", "#f88d8e","#f55657"]);
						colorC = d3.scaleLinear().domain([0,.25,.5,.75]).range(["#fcfcff", "#c5c5fc", "#8d8ef8", "#5657f5"]);
						colorD = d3.scaleLinear().domain([0,.25,.5,.75]).range(["#ffffff", "#858585", "#5c5c5c", "#000000"]);
					}
					if(interval == 6){
						colorB = d3.scaleLinear().domain([0,0.19,0.38,0.57,0.76,0.95]).range(["#fffcfc", "#fdd7d8", "#fbb2b3","#f88d8e", "#f6686a", "#f44345"]);
						colorC = d3.scaleLinear().domain([0,0.19,0.38,0.57,0.76,0.95]).range(["#fcfcff", "#d7d8fd", "#b2b3fb", "#8d8ef8", "#686af6","#4345f4"]);
						colorD = d3.scaleLinear().domain([0,0.19,0.38,0.57,0.76,0.95]).range(["#ffffff", "#cccccc", "#999999", "#666666", "#333333", "#000000"]);
					}
					if(interval == 8){
						colorB = d3.scaleLinear().domain([0,.125,.25,.375,.5,.675,.75,.875]).range(["#fffcfc", "#fdd7d8", "#fbb2b3","#f88d8e", "#f6686a", "#f44345", "#f21e20", "#dc0d0f"]);
						colorC = d3.scaleLinear().domain([0,.125,.25,.375,.5,.675,.75,.875]).range(["#fcfcff", "#d7d8fd", "#b2b3fb", "#8d8ef8", "#686af6","#4345f4", "#1e20f2", "#0e10ee"]);
						colorD = d3.scaleLinear().domain([0,.125,.25,.375,.5,.675,.75,.875]).range(["#ffffff", "#e0e0e0", "#c2c2c2", "#a3a3a3", "#7a7a7a", "#525252", "#292929", "#000000"]);
					}
				}

				// // colorD = "#fffbd8";
				// colorD = "white";
				// // colorB = "#f46d43";
				// colorB = "#f44345"; //f44345, f44373, f1134f (1), f44345 (2)
				// // colorA2 = d3.scaleLinear().domain(thresholds_A).range(["#fffcfc", "#fdd7d8", "#fbb2b3","#f88d8e", "#f6686a", "#f44345", "#f21e20", "#dc0d0f"]);
				// // colorA2 = d3.scaleLinear().domain(thresholds_B).range(["#fffcfc", "#fdd7d8", "#fbb2b3","#f88d8e", "#f6686a", "#f44345", "#f21e20", "#dc0d0f"]);
				// // colorA2 = d3.scaleLinear().domain(thresholds_C).range(["#fffcfc", "#fdd7d8", "#fbb2b3","#f88d8e", "#f6686a", "#f44345", "#f21e20", "#dc0d0f"]);
				// // colorA2 = d3.scaleLinear().domain(thresholds_D).range(["#fffcfc", "#fdd7d8", "#fbb2b3","#f88d8e", "#f6686a", "#f44345", "#f21e20", "#dc0d0f"]);
				// // colorC = "#74add1";
				// // colorC = "#3e8abb";
				// // colorC = "#4373f4";
				// colorC = "#4345f4"; // 4373f4 (1,2),

				window.polygonArea = function(pointArray) {
					area = 0; // Accumulates area
					numPoints = pointArray.length;
					j = numPoints - 1;
					X = new Array(pointArray.length);
					Y = new Array(pointArray.length);

					for (i = 0; i < pointArray.length; i++) {
						X[i] = pointArray[i][0];
						Y[i] = pointArray[i][1];
					}

					for (i = 0; i < numPoints; i++) {
						area += (X[j] + X[i]) * (Y[j] - Y[i]);
						j = i; //j is previous vertex to i
					}
					return area / 2;
				}

				if(document.getElementById("datasetForm").value == "synthetic1" || document.getElementById("datasetForm").value == "synthetic2"){
					getSimplifiedContours();
					contourtoWorkon = simplifiedContourA;
				}

				var lineGenerator = d3.line()
					.curve(d3.curveLinear)

				window.drawlineSimple = function(line) {
					line = line.map(function(x) {
						return [x[0] * mapRatio, x[1] * mapRatio];
					})
					lineout = lineGenerator(line)
					svg1.append("path")
						.attr("stroke", "black")
						.attr("stroke-width", .3)
						.attr("stroke-opacity", 1)
						// .attr("stroke-linejoin", "mitter")
						.attr("d", lineout)
				};

				// visualize
				if(designCurrent == 1){
					var barX = [];
					var barY = [];
					var FixsidesforBCflag = 0;

					window.drawBarsPL = function(line, threshval, currentContour) {

						// numCut = Math.floor(lineLen)*3;
						numCut = 30;
						line = line.map(function(x) {
							return [x[0] * mapRatio, x[1] * mapRatio];
						})
						angle = Math.atan2(line[1][1] - line[0][1], line[1][0] - line[0][0]);

						lineLen = Math.sqrt(Math.pow((line[0][0] - line[1][0]), 2) + Math.pow((line[0][1] - line[1][1]), 2));
						numCut = Math.floor(lineLen);

						for (x = 0; x <= numCut + 1; x++) {
							points++;
							// cutLine.push([(lineSlice[0][0]+lineSlice[1][0])*(i/(numCut+1)),(lineSlice[0][1]+lineSlice[1][1])*(i/(numCut+1))]);
							PointX = line[0][0] + (line[1][0] - line[0][0]) * (x / (numCut + 1));
							PointY = line[0][1] + (line[1][1] - line[0][1]) * (x / (numCut + 1));

							var lineStrokeWidth = thickness * getContourLabel(PointX / mapRatio, PointY / mapRatio, contourOutput_D);

							barX.push(PointX);
							barY.push(PointY);

							// Light
							bcolor = colorB;
							ccolor = colorC;
							bval = getContourLabel(PointX / mapRatio, PointY / mapRatio, contourOutput_B);
							// console.log('Temp threshold at ', PointX, ' & ', PointY, 'is: ', bval);
							bdist = thickness * bval;
							cval = getContourLabel(PointX / mapRatio, PointY / mapRatio, contourOutput_C);
							// console.log('Soil threshold at ', PointX, ' & ', PointY, 'is: ', cval);
							cdist = thickness * cval;
							// cdist = 15*threshval;
							dval = getContourLabel(PointX / mapRatio, PointY / mapRatio, contourOutput_D);
							// console.log('Soil threshold at ', PointX, ' & ', PointY, 'is: ', cval);
							ddist = thickness * dval;

							// PointX = PointX * mapRatio;
							// PointY = PointY * mapRatio;

							PointX1 = Math.sin(angle) * (thickness * .5) + PointX;
							PointY1 = -Math.cos(angle) * (thickness * .5) + PointY;
							PointX2 = -Math.sin(angle) * (thickness * .5) + PointX;
							PointY2 = Math.cos(angle) * (thickness * .5) + PointY;

							// demoX = Math.sin(angle)*20 + PointX1;
							// demoY = -Math.cos(angle)*20 + PointY1;

							if (FixsidesforBCflag == 1) {
								console.log('entered');
								FixsidesforBCflag = 0;
								demoX = -Math.sin(angle) * thickness + PointX;
								demoY = Math.cos(angle) * thickness + PointY;
								if (inside([demoX, demoY], currentContour) == false) {
									bFlag = 2;
								} else {
									bFlag = 1;
								}
							}

							if (x == 0) {
								if (bFlag == 2) {

									x1 = Math.sin(angle) * ((thickness * .5) + cdist) + PointX;
									y1 = -Math.cos(angle) * ((thickness * .5) + cdist) + PointY;
									x2 = -Math.sin(angle) * ((thickness * .5) + bdist) + PointX;
									y2 = Math.cos(angle) * ((thickness * .5) + bdist) + PointY;

									if (bdist > 0) {
										svg1.append("path")
											.attr("stroke", colorB)
											.attr("stroke-width", 1)
											// .attr("fill", colorD)
											// .attr("stroke-linecap", "round")
											.attr("d", lineGenerator([
												[PointX2, PointY2],
												[x2, y2]
											]))
									}
									if (cdist > 0) {
										svg1.append("path")
											.attr("stroke", colorC)
											.attr("stroke-width", 1)
											// .attr("fill", colorD)
											// .attr("stroke-linecap", "round")
											.attr("d", lineGenerator([
												[PointX1, PointY1],
												[x1, y1]
											]))
									}

									x1 = Math.sin(angle) * (ddist / 2) + PointX;
									y1 = -Math.cos(angle) * (ddist / 2) + PointY;
									x2 = -Math.sin(angle) * (ddist / 2) + PointX;
									y2 = Math.cos(angle) * (ddist / 2) + PointY;

									if (ddist > 0) {
										svg1.append("path")
											.attr("stroke", colorD)
											.attr("stroke-width", 1)
											// .attr("fill", colorD)
											// .attr("stroke-linecap", "round")
											.attr("d", lineGenerator([
												[x1, y1],
												[x2, y2]
											]))
									}
								} else {
									x1 = Math.sin(angle) * ((thickness * .5) + bdist) + PointX;
									y1 = -Math.cos(angle) * ((thickness * .5) + bdist) + PointY;
									x2 = -Math.sin(angle) * ((thickness * .5) + cdist) + PointX;
									y2 = Math.cos(angle) * ((thickness * .5) + cdist) + PointY;

									if (bdist > 0) {
										svg1.append("path")
											.attr("stroke", colorB)
											.attr("stroke-width", 1)
											// .attr("fill", colorD)
											// .attr("stroke-linecap", "round")
											.attr("d", lineGenerator([
												[PointX1, PointY1],
												[x1, y1]
											]))
									}
									if (cdist > 0) {
										svg1.append("path")
											.attr("stroke", colorC)
											.attr("stroke-width", 1)
											// .attr("fill", colorD)
											// .attr("stroke-linecap", "round")
											.attr("d", lineGenerator([
												[PointX2, PointY2],
												[x2, y2]
											]))
									}
									x1 = Math.sin(angle) * (ddist / 2) + PointX;
									y1 = -Math.cos(angle) * (ddist / 2) + PointY;
									x2 = -Math.sin(angle) * (ddist / 2) + PointX;
									y2 = Math.cos(angle) * (ddist / 2) + PointY;

									if (ddist > 0) {
										svg1.append("path")
											.attr("stroke", colorD)
											.attr("stroke-width", 1)
											// .attr("fill", colorD)
											// .attr("stroke-linecap", "round")
											.attr("d", lineGenerator([
												[x1, y1],
												[x2, y2]
											]))
									}
								}
							} else {
								if (bFlag == 2) {

									x1 = Math.sin(angle) * ((thickness * .5) + cdist) + PointX;
									y1 = -Math.cos(angle) * ((thickness * .5) + cdist) + PointY;
									x2 = -Math.sin(angle) * ((thickness * .5) + bdist) + PointX;
									y2 = Math.cos(angle) * ((thickness * .5) + bdist) + PointY;

									if (bdist > 0) {
										svg1.append("path")
											.attr("stroke", colorB)
											.attr("stroke-width", 1)
											// .attr("fill", colorD)
											// .attr("stroke-linecap", "round")
											.attr("d", lineGenerator([
												[PointX2, PointY2],
												[x2, y2]
											]))
									}
									if (cdist > 0) {
										svg1.append("path")
											.attr("stroke", colorC)
											.attr("stroke-width", 1)
											// .attr("fill", colorD)
											// .attr("stroke-linecap", "round")
											.attr("d", lineGenerator([
												[PointX1, PointY1],
												[x1, y1]
											]))
									}
									x1 = Math.sin(angle) * (ddist / 2) + PointX;
									y1 = -Math.cos(angle) * (ddist / 2) + PointY;
									x2 = -Math.sin(angle) * (ddist / 2) + PointX;
									y2 = Math.cos(angle) * (ddist / 2) + PointY;

									if (ddist > 0) {
										svg1.append("path")
											.attr("stroke", colorD)
											.attr("stroke-width", 1)
											// .attr("fill", colorD)
											// .attr("stroke-linecap", "round")
											.attr("d", lineGenerator([
												[x1, y1],
												[x2, y2]
											]))
									}
								} else {

									x1 = Math.sin(angle) * ((thickness * .5) + bdist) + PointX;
									y1 = -Math.cos(angle) * ((thickness * .5) + bdist) + PointY;
									x2 = -Math.sin(angle) * ((thickness * .5) + cdist) + PointX;
									y2 = Math.cos(angle) * ((thickness * .5) + cdist) + PointY;

									if (bdist > 0) {
										svg1.append("path")
											.attr("stroke", colorB)
											.attr("stroke-width", 1)
											// .attr("fill", colorD)
											// .attr("stroke-linecap", "round")
											.attr("d", lineGenerator([
												[PointX1, PointY1],
												[x1, y1]
											]))
									}
									if (cdist > 0) {
										svg1.append("path")
											.attr("stroke", colorC)
											.attr("stroke-width", 1)
											// .attr("fill", colorD)
											// .attr("stroke-linecap", "round")
											.attr("d", lineGenerator([
												[PointX2, PointY2],
												[x2, y2]
											]))
									}
									x1 = Math.sin(angle) * (ddist / 2) + PointX;
									y1 = -Math.cos(angle) * (ddist / 2) + PointY;
									x2 = -Math.sin(angle) * (ddist / 2) + PointX;
									y2 = Math.cos(angle) * (ddist / 2) + PointY;

									if (ddist > 0) {
										svg1.append("path")
											.attr("stroke", colorD)
											.attr("stroke-width", 1)
											// .attr("fill", colorD)
											// .attr("stroke-linecap", "round")
											.attr("d", lineGenerator([
												[x1, y1],
												[x2, y2]
											]))
									}
								}
							}
						}
					}

						for (len = 0; len < contourtoWorkon.length; len++) {
							for (cor = 0; cor < contourtoWorkon[len]["coordinates"].length; cor++) {
								for (cornum = 0; cornum < contourtoWorkon[len]["coordinates"][cor].length; cornum++) {
									var simplified = contourtoWorkon[len]["coordinates"][cor][cornum];
									if (Math.abs(polygonArea(Object.values(simplified))) > 5) {
										for (y = 0; y < simplified.length - 1; y++) {
											lineSlice = simplified.slice(y, y + 2);
											drawlineSimple(lineSlice);
										}
									}
								}
							}
						}

						//draw two sided plots
						for (len = 0; len < contourtoWorkon.length; len++) {
							if (len == 0) {
								FixsidesforBCflag = 1;
							}
							for (cor = 0; cor < contourtoWorkon[len]["coordinates"].length; cor++) {
								for (cornum = 0; cornum < contourtoWorkon[len]["coordinates"][cor].length; cornum++) {
									var simplified = contourtoWorkon[len]["coordinates"][cor][cornum];
									if (Math.abs(polygonArea(Object.values(simplified))) > 5) {
										for (y = 0; y < simplified.length - 1; y++) {
											lineSlice = simplified.slice(y, y + 2);
											lineLength = Math.sqrt(Math.pow((lineSlice[0][0] - lineSlice[1][0]), 2) + Math.pow((lineSlice[0][1] - lineSlice[1][1]), 2));
											// if ((lineSlice[0][0] >= vHeight-1 || lineSlice[0][0] <= 1 || lineSlice[0][1] >= vWidth-1 || lineSlice[0][1] <= 1) && (lineSlice[1][0] >= vWidth-1 || lineSlice[1][0] <= 1 || lineSlice[1][1] >= vHeight-1 || lineSlice[1][1] <= 1)) {
											if ((lineSlice[0][0] * mapRatio >= svgheight - 5 || lineSlice[0][0] * mapRatio <= 5 || lineSlice[0][1] * mapRatio >= svgwidth - 5 || lineSlice[0][1] * mapRatio <= 5) && (lineSlice[1][0] * mapRatio >= svgwidth - 5 ||
													lineSlice[1]
													[
														0
													] * mapRatio <= 5 || lineSlice[1][1] * mapRatio >= svgheight - 5 || lineSlice[1][1] * mapRatio <= 5)) {
												drawlineSimple(lineSlice);
												continue;
											}
											drawBarsPL(lineSlice, contourtoWorkon[len]["value"], simplified);
										}
									}
								}
							}
						}

						svg1.append("rect")
								.attr("x", 707)
								.attr("y", 680)
								.attr("width", 85)
								.attr("height", 112)
								.attr("fill","#dddddd");

						if(document.getElementById("datasetForm").value == "synthetic1" || document.getElementById("datasetForm").value == "synthetic2"){
							svg1.append("text")
								.text("B")
								.attr("x", 685)
								.attr("y", 700)
								.attr("font-size", 20)
								.attr("font-family", "sans-serif")
								.attr("fill", "black")
								.attr("stroke", "black");
							svg1.append("text")
								.text("C")
								.attr("x", 685)
								.attr("y", 740)
								.attr("font-size", 20)
								.attr("font-family", "sans-serif")
								.attr("fill", "black")
								.attr("stroke", "black");
							svg1.append("text")
								.text("D")
								.attr("x", 685)
								.attr("y", 780)
								.attr("font-size", 20)
								.attr("font-family", "sans-serif")
								.attr("fill", "black")
								.attr("stroke", "black");
						}
						else if(document.getElementById("datasetForm").value == "real1" || document.getElementById("datasetForm").value == "real2"){
							svg1.append("text")
								.text("Soil Moisture")
								.attr("x", 723)
								.attr("y", 707)
								.attr("font-size", 10)
								.attr("font-family", "sans-serif")
								.attr("fill", "black")
								.attr("stroke", "black");
							svg1.append("text")
								.text("Pressure")
								.attr("x", 730)
								.attr("y", 747)
								.attr("font-size", 10)
								.attr("font-family", "sans-serif")
								.attr("fill", "black")
								.attr("stroke", "black");
							svg1.append("text")
								.text("Temperature")
								.attr("x", 723)
								.attr("y", 787)
								.attr("font-size", 10)
								.attr("font-family", "sans-serif")
								.attr("fill", "black")
								.attr("stroke", "black");
						}

						window.drawLegend_PL = function(line, thresArray, constLength, barcolor){
									drawlineSimple(line);
									numCut = 24;
									for (x=1;x<=numCut;x++){
										PointX = line[0][0]+(line[1][0]-line[0][0])*(x/(numCut+1));
										PointY = line[0][1]+(line[1][1]-line[0][1])*(x/(numCut+1));
										angle = Math.atan2(line[1][1] - line[0][1], line[1][0] - line[0][0]);

										if(interval == 4){
											barLength = thresArray[Math.floor((x-1)/6)];
										}
										else if(interval == 6){
											barLength = thresArray[Math.floor((x-1)/4)];
										}
										else if(interval == 8){
											barLength = thresArray[Math.floor((x-1)/3)];
										}

										PointX = PointX * mapRatio;
										PointY = PointY * mapRatio;

										demoy1 = -Math.cos(angle) * 10 + PointY;
										demoy2 = Math.cos(angle) * 10 + PointY;

										if (demoy1 < demoy2){
											x1 = Math.sin(angle) * barLength * constLength + PointX;
											y1 = -Math.cos(angle) * barLength * constLength + PointY;
											svg1.append("path")
												 .attr("stroke", barcolor)
												 .attr("stroke-width", 5)
												 .attr("d",'M'+ x1 + ',' + y1 + 'L' + PointX + ',' + PointY)
										}
										else{
											x2 = -Math.sin(angle) * barLength * constLength + PointX;
											y2 = Math.cos(angle) * barLength * constLength + PointY;
											svg1.append("path")
													.attr("stroke", barcolor)
													.attr("stroke-width", 5)
													.attr("d",'M'+ x2 + ',' + y2 + 'L' + PointX + ',' + PointY)
										}
									}
								}
								drawLegend_PL([[178,174],[197,174]], thresholds_B, thickness, colorB);
								drawLegend_PL([[178,184],[197,184]], thresholds_C, thickness, colorC);
								drawLegend_PL([[178,194],[197,194]], thresholds_D, thickness, colorD);

				}

				if(designCurrent == 2){

					window.drawlineColorBlendCB = function(line, threshval) {

						line = line.map(function(x) {
							return [x[0] * mapRatio, x[1] * mapRatio];
						})
						lineLen = Math.sqrt(Math.pow((line[0][0] - line[1][0]), 2) + Math.pow((line[0][1] - line[1][1]), 2));
						numCut = Math.floor(lineLen);

						for (xx = 0; xx <= numCut + 1; xx++) {
							if (xx == 0) {
								pointXprev = line[0][0];
								pointYprev = line[0][1];
							}

							// cutLine.push([(lineSlice[0][0]+lineSlice[1][0])*(i/(numCut+1)),(lineSlice[0][1]+lineSlice[1][1])*(i/(numCut+1))]);
							PointX = line[0][0] + (line[1][0] - line[0][0]) * (xx / (numCut + 1));
							PointY = line[0][1] + (line[1][1] - line[0][1]) * (xx / (numCut + 1));

							lineout = lineGenerator([
								[pointXprev, pointYprev],
								[PointX, PointY]
							])

							bval = getContourLabel(PointX / mapRatio, PointY / mapRatio, contourOutput_B);
							cval = getContourLabel(PointX / mapRatio, PointY / mapRatio, contourOutput_C);
							dval = getContourLabel(PointX / mapRatio, PointY / mapRatio, contourOutput_D);

							var Bcolor = colorB(bval);
							var Ccolor = colorC(cval);

							BcolorR = parseInt(Bcolor.split(',')[0].split('(')[1]);
							BcolorG = parseInt(Bcolor.split(',')[1]);
							BcolorB = parseInt(Bcolor.split(',')[2].split(')')[0]);

							CcolorR = parseInt(Ccolor.split(',')[0].split('(')[1]);
							CcolorG = parseInt(Ccolor.split(',')[1]);
							CcolorB = parseInt(Ccolor.split(',')[2].split(')')[0]);

							blendR = (BcolorR * CcolorR) / 255;
							blendG = (BcolorG * CcolorG) / 255;
							blendB = (BcolorB * CcolorB) / 255;

							colorBlend = "rgb(" + blendR.toString() + ", " + blendG.toString() + ", " + blendB.toString() + ")";

							lineStrokeWidth = thickness * dval + 1;

							// console.log(lineout);
							svg1.append("path")
								.attr("d", lineout)
								.attr("stroke", colorBlend)
								.attr("stroke-width", lineStrokeWidth)
								.attr("fill", colorBlend)
							// .attr("stroke-opacity",1)
							// .attr("stroke-linecap", "butt")

							pointXprev = PointX;
							pointYprev = PointY;
						}
					};

					for (len = 0; len < contourtoWorkon.length; len++) {
						for (cor = 0; cor < contourtoWorkon[len]["coordinates"].length; cor++) {
							for (cornum = 0; cornum < contourtoWorkon[len]["coordinates"][cor].length; cornum++) {
								var simplified = contourtoWorkon[len]["coordinates"][cor][cornum];
								if (Math.abs(polygonArea(Object.values(simplified))) > 20) {
									for (y = 0; y < simplified.length - 1; y++) {
										lineSlice = simplified.slice(y, y + 2);
										lineLength = Math.sqrt(Math.pow((lineSlice[0][0] - lineSlice[1][0]), 2) + Math.pow((lineSlice[0][1] - lineSlice[1][1]), 2));
										if ((lineSlice[0][0] >= vHeight - 1 || lineSlice[0][0] <= 1 || lineSlice[0][1] >= vWidth - 1 || lineSlice[0][1] <= 1) && (lineSlice[1][0] >= vWidth - 1 || lineSlice[1][0] <= 1 || lineSlice[1][1] >= vHeight - 1 || lineSlice[
												1][
												1
											] <= 1)) {
											drawlineSimple(lineSlice);
										} else {
											var numCut = Math.floor(lineLength);
											var cutLine = [lineSlice[0]];
											// console.log('Before Cut: ', lineSlice, ' / length: ', lineLength, ' / cuts needed: ', numCut);
											for (i = 1; i <= numCut; i++) {
												cutLine.push([lineSlice[0][0] + (lineSlice[1][0] - lineSlice[0][0]) * (i / (numCut + 1)), lineSlice[0][1] + (lineSlice[1][1] - lineSlice[0][1]) * (i / (numCut + 1))]);
											}
											cutLine.push(lineSlice[1]);
											// console.log('After cut: ', cutLine);
											for (jj = 0; jj < cutLine.length - 1; jj++) {
												drawlineColorBlendCB(cutLine.slice(jj, jj + 2), contourtoWorkon[len]["value"]);
											}
										}
									}
								}
							}
						}
					}

						if(interval == 4){
							svg1.append("rect")
										.attr("x", 707)
										.attr("y", 679)
										.attr("width", 90)
										.attr("height", 118)
										.attr("fill", "#dddddd");

							window.drawLegendD_CB1 = function(colorLegend){
													svg1.append("path")
														.attr("stroke", colorLegend)
														.attr("stroke-width", 1)
														.attr("fill", "none")
														.attr("d",'M'+ 730 + ',' + 703 + 'L'+ 790 + ',' + 697 +'L'+ 790 + ',' + 713 +'L'+ 730 + ',' + 710 + 'L' + 730 + ',' + 707 + 'L'+ 730 + ',' + 703)
									}
							drawLegendD_CB1("black");

							window.drawLegendBC_CB1 = function(startPoint, thresArrayB, thresArrayC){
								for (r=0;r<4;r++){
									for(c=0;c<4;c++){
										px = startPoint[0] + (r*15);
										py = startPoint[1] + (c*15);

										Bcolor = colorB(thresArrayB[3-c]);
										Ccolor = colorC(thresArrayC[r]);

										BcolorR = parseInt(Bcolor.split(',')[0].split('(')[1]);
										BcolorG = parseInt(Bcolor.split(',')[1]);
										BcolorB = parseInt(Bcolor.split(',')[2].split(')')[0]);

										CcolorR = parseInt(Ccolor.split(',')[0].split('(')[1]);
										CcolorG = parseInt(Ccolor.split(',')[1]);
										CcolorB = parseInt(Ccolor.split(',')[2].split(')')[0]);

										blendR = (BcolorR * CcolorR) / 255;
										blendG = (BcolorG * CcolorG) / 255;
										blendB = (BcolorB * CcolorB) / 255;

										colorBlend = "rgb("+blendR.toString()+", "+blendG.toString()+", "+blendB.toString()+")";

										svg1.append("rect")
										    .attr("x", px)
											 	.attr("y", py)
												.attr("width", 15)
										    .attr("height", 15)
												.attr("fill",colorBlend);
									}
								}
							}
							drawLegendBC_CB1([730,720], thresholds_B, thresholds_C);
						}
						else if(interval == 6){
							svg1.append("rect")
										.attr("x", 672)
										.attr("y", 639)
										.attr("width", 125)
										.attr("height", 158)
										.attr("fill", "#dddddd");

							window.drawLegendD_CB2 = function(colorLegend){
													svg1.append("path")
														.attr("stroke", colorLegend)
														.attr("stroke-width", 1)
														.attr("fill", "none")
														.attr("d",'M'+ 700 + ',' + 662.5 + 'L'+ 790 + ',' + 655 +'L'+ 790 + ',' + 675 +'L'+ 700 + ',' + 670 + 'L' + 700 + ',' + 667.5 + 'L'+ 700 + ',' + 662.5)
									}
							drawLegendD_CB2("black");

							window.drawLegendBC_CB2 = function(startPoint, thresArrayB, thresArrayC){
								for (r=0;r<6;r++){
									for(c=0;c<6;c++){
										px = startPoint[0] + (r*15);
										py = startPoint[1] + (c*15);

										Bcolor = colorB(thresArrayB[5-c]);
										Ccolor = colorC(thresArrayC[r]);

										BcolorR = parseInt(Bcolor.split(',')[0].split('(')[1]);
										BcolorG = parseInt(Bcolor.split(',')[1]);
										BcolorB = parseInt(Bcolor.split(',')[2].split(')')[0]);

										CcolorR = parseInt(Ccolor.split(',')[0].split('(')[1]);
										CcolorG = parseInt(Ccolor.split(',')[1]);
										CcolorB = parseInt(Ccolor.split(',')[2].split(')')[0]);

										blendR = (BcolorR * CcolorR) / 255;
										blendG = (BcolorG * CcolorG) / 255;
										blendB = (BcolorB * CcolorB) / 255;

										colorBlend = "rgb("+blendR.toString()+", "+blendG.toString()+", "+blendB.toString()+")";
										if(r > 3 && c > 3){
											console.log(colorBlend);
										}


										svg1.append("rect")
										    .attr("x", px)
											 	.attr("y", py)
												.attr("width", 15)
										    .attr("height", 15)
												.attr("fill",colorBlend);
									}
								}
							}
							drawLegendBC_CB2([700,680], thresholds_B, thresholds_C);
						}
						else if(interval == 8){
							svg1.append("rect")
										.attr("x", 642)
										.attr("y", 609)
										.attr("width", 155)
										.attr("height", 188)
										.attr("fill", "#dddddd");

							window.drawLegendD_CB3 = function(colorLegend){
													svg1.append("path")
														.attr("stroke", colorLegend)
														.attr("stroke-width", 1)
														.attr("fill", "none")
														.attr("d",'M'+ 672 + ',' + 637.5 + 'L'+ 788 + ',' + 630 +'L'+ 788 + ',' + 650 +'L'+ 672 + ',' + 645 + 'L' + 672 + ',' + 642.5 + 'L'+ 672 + ',' + 637.5)
									}
							drawLegendD_CB3("black");

							window.drawLegendBC_CB3 = function(startPoint, thresArrayB, thresArrayC){
								for (r=0;r<8;r++){
									for(c=0;c<8;c++){
										px = startPoint[0] + (r*15);
										py = startPoint[1] + (c*15);

										Bcolor = colorB(thresArrayB[7-c]);
										Ccolor = colorC(thresArrayC[r]);

										BcolorR = parseInt(Bcolor.split(',')[0].split('(')[1]);
										BcolorG = parseInt(Bcolor.split(',')[1]);
										BcolorB = parseInt(Bcolor.split(',')[2].split(')')[0]);

										CcolorR = parseInt(Ccolor.split(',')[0].split('(')[1]);
										CcolorG = parseInt(Ccolor.split(',')[1]);
										CcolorB = parseInt(Ccolor.split(',')[2].split(')')[0]);

										blendR = (BcolorR * CcolorR) / 255;
										blendG = (BcolorG * CcolorG) / 255;
										blendB = (BcolorB * CcolorB) / 255;

										colorBlend = "rgb("+blendR.toString()+", "+blendG.toString()+", "+blendB.toString()+")";

										svg1.append("rect")
										    .attr("x", px)
											 	.attr("y", py)
												.attr("width", 15)
										    .attr("height", 15)
												.attr("fill",colorBlend);
									}
								}
							}
							drawLegendBC_CB3([670,655], thresholds_B, thresholds_C);
						}

					if(document.getElementById("datasetForm").value == "synthetic1" || document.getElementById("datasetForm").value == "synthetic2"){
						if(interval == 4){
							svg1.append("text")
								.text("B")
								.attr("x", 710)
								.attr("y", 713)
								.attr("font-size", 20)
								.attr("font-family", "sans-serif")
								.attr("fill", "black")
								.attr("stroke", "black")
							svg1.append("text")
								.text("D")
								.attr("x", 753)
								.attr("y", 796)
								.attr("font-size", 20)
								.attr("font-family", "sans-serif")
								.attr("fill", "black")
								.attr("stroke", "black")
							svg1.append("text")
								.text("C")
								.attr("x", 710)
								.attr("y", 755)
								.attr("font-size", 20)
								.attr("font-family", "sans-serif")
								.attr("fill", "black")
								.attr("stroke", "black")
						}
						else if(interval == 6){
							svg1.append("text")
								.text("B")
								.attr("x", 680)
								.attr("y", 675)
								.attr("font-size", 20)
								.attr("font-family", "sans-serif")
								.attr("fill", "black")
								.attr("stroke", "black")
							svg1.append("text")
								.text("D")
								.attr("x", 738)
								.attr("y", 791)
								.attr("font-size", 20)
								.attr("font-family", "sans-serif")
								.attr("fill", "black")
								.attr("stroke", "black")
							svg1.append("text")
								.text("C")
								.attr("x", 680)
								.attr("y", 730)
								.attr("font-size", 20)
								.attr("font-family", "sans-serif")
								.attr("fill", "black")
								.attr("stroke", "black")
						}
						else if(interval == 8){
							svg1.append("text")
								.text("B")
								.attr("x", 650)
								.attr("y", 648)
								.attr("font-size", 20)
								.attr("font-family", "sans-serif")
								.attr("fill", "black")
								.attr("stroke", "black")
							svg1.append("text")
								.text("D")
								.attr("x", 725)
								.attr("y", 792)
								.attr("font-size", 20)
								.attr("font-family", "sans-serif")
								.attr("fill", "black")
								.attr("stroke", "black")
							svg1.append("text")
								.text("C")
								.attr("x", 650)
								.attr("y", 720)
								.attr("font-size", 20)
								.attr("font-family", "sans-serif")
								.attr("fill", "black")
								.attr("stroke", "black")
						}
					}
					else if(document.getElementById("datasetForm").value == "real1" || document.getElementById("datasetForm").value == "real2"){
						if(interval == 4){
							svg1.append("text")
								.text("Temperature")
								.attr("x", 730)
								.attr("y", 690)
								.attr("font-size", 10)
								.attr("font-family", "sans-serif")
								.attr("fill", "black")
								.attr("stroke", "black")
							svg1.append("text")
								.text("Pressure")
								.attr("x", 740)
								.attr("y", 792)
								.attr("font-size", 10)
								.attr("font-family", "sans-serif")
								.attr("fill", "black")
								.attr("stroke", "black")
							svg1.append("text")
								.text("Soil Moisture")
								.attr("x", 720)
								.attr("y", 780)
								.attr("font-size", 10)
								.attr("font-family", "sans-serif")
								.attr("fill", "black")
								.attr("stroke", "black")
								.attr("transform","rotate(-90,720,780)");
						}
						else if(interval == 6){
							svg1.append("text")
								.text("Temperature")
								.attr("x", 720)
								.attr("y", 650)
								.attr("font-size", 10)
								.attr("font-family", "sans-serif")
								.attr("fill", "black")
								.attr("stroke", "black")
							svg1.append("text")
								.text("Pressure")
								.attr("x", 725)
								.attr("y", 785)
								.attr("font-size", 10)
								.attr("font-family", "sans-serif")
								.attr("fill", "black")
								.attr("stroke", "black")
							svg1.append("text")
								.text("Soil Moisture")
								.attr("x", 690)
								.attr("y", 750)
								.attr("font-size", 10)
								.attr("font-family", "sans-serif")
								.attr("fill", "black")
								.attr("stroke", "black")
								.attr("transform","rotate(-90,690,750)");
						}
						else if(interval == 8){
							svg1.append("text")
								.text("Temperature")
								.attr("x", 700)
								.attr("y", 625)
								.attr("font-size", 10)
								.attr("font-family", "sans-serif")
								.attr("fill", "black")
								.attr("stroke", "black")
							svg1.append("text")
								.text("Pressure")
								.attr("x", 710)
								.attr("y", 790)
								.attr("font-size", 10)
								.attr("font-family", "sans-serif")
								.attr("fill", "black")
								.attr("stroke", "black")
							svg1.append("text")
								.text("Soil Moisture")
								.attr("x", 660)
								.attr("y", 745)
								.attr("font-size", 10)
								.attr("font-family", "sans-serif")
								.attr("fill", "black")
								.attr("stroke", "black")
								.attr("transform","rotate(-90,660,745)");
						}
					}
				}

				if(designCurrent == 3){
					window.drawPie = function(line, currentContour){

						pieRadius = thickness/2;
						// pieRadius = threshval*10 + 5;

						lineLen = Math.sqrt(Math.pow((line[0][0]-line[1][0]), 2) + Math.pow((line[0][1]-line[1][1]), 2));
						// numCut = Math.floor(lineLen/pieRadius);
						numCut = Math.floor(lineLen)*4;
						// numCut = 1;
						line = line.map(function(x) { return [x[0] * mapRatio,x[1] * mapRatio]; })

						// TempCoordinates = "";
						// SoilCoordinates = "";
						// TempCoordinates = TempCoordinates.concat("M ",line[0][0],' ',line[0][1]);
						// SoilCoordinates = SoilCoordinates.concat("M ",line[0][0],' ',line[0][1]);

						for (x=0;x<=numCut+1;x++){
							PointX = line[0][0]+(line[1][0]-line[0][0])*(x/(numCut+1));
							PointY = line[0][1]+(line[1][1]-line[0][1])*(x/(numCut+1));

							if(contourStart > 0 && Math.sqrt(Math.pow((pieX[pieIndex]-PointX), 2) + Math.pow((pieY[pieIndex]-PointY), 2)) <= pieRadius*2 ){
								continue;
							}
							pieX.push(PointX);
							pieY.push(PointY);
							pieIndex++;
							// pcolor = "blue";
							// angle = Math.atan2(line[1][1] - line[0][1], line[1][0] - line[0][0]);
							// pval = threshval;
							// pdist = 20*threshval;
							Bval = getContourLabel(PointX/mapRatio, PointY/mapRatio, contourOutput_B);
							// tdist = 20*Bval;
							Cval = getContourLabel(PointX/mapRatio, PointY/mapRatio, contourOutput_C);
							// sdist = 20*Cval;
							Dval = getContourLabel(PointX/mapRatio, PointY/mapRatio, contourOutput_D);

							// pStart = [PointX+(pieRadius*Math.cos(90*(Math.PI/180))) , PointY-(pieRadius*Math.sin(90*(Math.PI/180)))];
							// pEnd = [PointX+(pieRadius*Math.cos((90-(120*pval))*(Math.PI/180))) , PointY-(pieRadius*Math.sin((90-(120*pval))*(Math.PI/180)))];
							Bstart = [PointX+(pieRadius*Math.cos(90*(Math.PI/180))) , PointY-(pieRadius*Math.sin(90*(Math.PI/180)))];
							Bend = [PointX+(pieRadius*Math.cos((90-(120*Bval))*(Math.PI/180))) , PointY-(pieRadius*Math.sin((90-(120*Bval))*(Math.PI/180)))];
							Cstart = [PointX+(pieRadius*Math.cos(330*(Math.PI/180))) , PointY-(pieRadius*Math.sin(330*(Math.PI/180)))];
							Cend = [PointX+(pieRadius*Math.cos((330-(120*Cval))*(Math.PI/180))) , PointY-(pieRadius*Math.sin((330-(120*Cval))*(Math.PI/180)))];
							Dstart = [PointX+(pieRadius*Math.cos(210*(Math.PI/180))) , PointY-(pieRadius*Math.sin(210*(Math.PI/180)))];
							Dend = [PointX+(pieRadius*Math.cos((210-(120*Dval))*(Math.PI/180))) , PointY-(pieRadius*Math.sin((210-(120*Dval))*(Math.PI/180)))];

							// demox1 = Math.sin(angle)*10 + PointX;
							// demox2 = -Math.sin(angle)*10 + PointX;

							svg1.append("circle")
								.attr("cx",PointX)
								.attr("cy",PointY)
								.attr("r",pieRadius)
								.attr("stroke","black")
								.attr("stroke-width",.3)
								// .attr("opacity",.5)
								.attr("fill", "none")
							// pathStringPres = "M "+pStart[0]+" "+pStart[1]+" A "+pieRadius+" "+pieRadius+" 0 0 1 "+pEnd[0]+" "+pEnd[1]+ " L "+PointX+" "+PointY;
							pathStringB = "M "+Bstart[0]+" "+Bstart[1]+" A "+pieRadius+" "+pieRadius+" 0 0 1 "+Bend[0]+" "+Bend[1]+ " L "+PointX+" "+PointY;
							pathStringC = "M "+Cstart[0]+" "+Cstart[1]+" A "+pieRadius+" "+pieRadius+" 0 0 1 "+Cend[0]+" "+Cend[1]+ " L "+PointX+" "+PointY;
							pathStringD = "M "+Dstart[0]+" "+Dstart[1]+" A "+pieRadius+" "+pieRadius+" 0 0 1 "+Dend[0]+" "+Dend[1]+ " L "+PointX+" "+PointY;

							svg1.append("path")
								.attr("stroke", colorB)
								.attr("stroke-width", 1)
								.attr("fill", colorB)
								// .attr("opacity",.5)
								.attr("d",pathStringB)

							svg1.append("path")
								.attr("stroke", colorC)
								.attr("stroke-width", 1)
								.attr("fill", colorC)
								// .attr("opacity",.5)
								.attr("d",pathStringC)

							svg1.append("path")
								.attr("stroke", colorD)
								.attr("stroke-width", 1)
								.attr("fill", colorD)
								// .attr("opacity",.5)
							.attr("d",pathStringD)
						}
					}

					// drawing pies
					for (len=0;len<contourtoWorkon.length;len++){
						for(cor=0;cor<contourtoWorkon[len]["coordinates"].length;cor++){
							for(cornum=0;cornum<contourtoWorkon[len]["coordinates"][cor].length;cornum++){
								// var simplified = simplify(contourtoWorkon[len]["coordinates"][cor][cornum],2);
								var simplified = contourtoWorkon[len]["coordinates"][cor][cornum];
								pieX = [];
								pieY = [];
								pieIndex = -1;
								contourStart = 0;
								if (Math.abs(polygonArea(Object.values(simplified))) > 20){
									for(y=0;y<simplified.length-1;y++){
										lineSlice = simplified.slice(y,y+2);
										lineLength = Math.sqrt(Math.pow((lineSlice[0][0]-lineSlice[1][0]), 2) + Math.pow((lineSlice[0][1]-lineSlice[1][1]), 2));
										// if(lineLength > 100){
										// if ((lineSlice[0][0] >= 195 || lineSlice[0][0] <= 5 || lineSlice[0][1] >= 195 || lineSlice[0][1] <= 5) && (lineSlice[1][0] >= 195 || lineSlice[1][0] <= 5 || lineSlice[1][1] >= 195 || lineSlice[1][1] <= 5)) {
										if ((lineSlice[0][0] >= vHeight-1 || lineSlice[0][0] <= 1 || lineSlice[0][1] >= vWidth-1 || lineSlice[0][1] <= 1) && (lineSlice[1][0] >= vWidth-1 || lineSlice[1][0] <= 1 || lineSlice[1][1] >= vHeight-1 || lineSlice[1][1] <= 1)) {
											drawlineSimple(lineSlice);
											console.log("line drew assimple");
											continue;
										}
										contourStart++;
										drawPie(lineSlice, simplified);
									}
								}
							}
						}
					}

					svg1.append("rect")
							.attr("x", 657)
							.attr("y", 690)
							.attr("width", 135)
							.attr("height", 100)
							.attr("fill","#dddddd");

					window.drawLegendBCD = function(centerL, radiusL){
						svg1.append("circle")
							.attr("cx",centerL[0])
							.attr("cy",centerL[1])
							.attr("r",radiusL)
							.attr("stroke", "#dddddd")
							.attr("stroke-width", .5)
							.attr("fill", "#dddddd")

							// pvalL = .4;
							BvalL = .5;
							CvalL = .8;
							DvalL = .6;

							// pStartL = [centerL[0]+(radiusL*Math.cos(90*(Math.PI/180))) , centerL[1]-(radiusL*Math.sin(90*(Math.PI/180)))];
							// pEndL = [centerL[0]+(radiusL*Math.cos((90-(120*pvalL))*(Math.PI/180))) , centerL[1]-(radiusL*Math.sin((90-(120*pvalL))*(Math.PI/180)))];
							BstartL = [centerL[0]+(radiusL*Math.cos(90*(Math.PI/180))) , centerL[1]-(radiusL*Math.sin(90*(Math.PI/180)))];
							BendL = [centerL[0]+(radiusL*Math.cos((90-(120*BvalL))*(Math.PI/180))) , centerL[1]-(radiusL*Math.sin((90-(120*BvalL))*(Math.PI/180)))];
							CstartL = [centerL[0]+(radiusL*Math.cos(330*(Math.PI/180))) , centerL[1]-(radiusL*Math.sin(330*(Math.PI/180)))];
							CendL = [centerL[0]+(radiusL*Math.cos((330-(120*CvalL))*(Math.PI/180))) , centerL[1]-(radiusL*Math.sin((330-(120*CvalL))*(Math.PI/180)))];
							DstartL = [centerL[0]+(radiusL*Math.cos(210*(Math.PI/180))) , centerL[1]-(radiusL*Math.sin(210*(Math.PI/180)))];
							DendL = [centerL[0]+(radiusL*Math.cos((210-(120*DvalL))*(Math.PI/180))) , centerL[1]-(radiusL*Math.sin((210-(120*DvalL))*(Math.PI/180)))];

							// pathStringPresL = "M "+pStartL[0]+" "+pStartL[1]+" A "+radiusL+" "+radiusL+" 0 0 1 "+pEndL[0]+" "+pEndL[1]+ " L "+centerL[0]+" "+centerL[1];
							pathStringBL = "M "+BstartL[0]+" "+BstartL[1]+" A "+radiusL+" "+radiusL+" 0 0 1 "+BendL[0]+" "+BendL[1]+ " L "+centerL[0]+" "+centerL[1];
							pathStringCL = "M "+CstartL[0]+" "+CstartL[1]+ " A "+radiusL+" "+radiusL+" 0 0 1 " +CendL[0]+" "+CendL[1]+ " L "+centerL[0]+" "+centerL[1];
							pathStringDL = "M "+DstartL[0]+" "+DstartL[1]+" A "+radiusL+" "+radiusL+" 0 0 1 "+DendL[0]+" "+DendL[1]+ " L "+centerL[0]+" "+centerL[1];

							svg1.append("path")
								.attr("stroke", colorB)
								.attr("stroke-width", 1)
								.attr("fill", colorB)
								// .attr("opacity",.5)
								.attr("d",pathStringBL)
							svg1.append("path")
								.attr("stroke", colorC)
								.attr("stroke-width", 1)
								.attr("fill", colorC)
								// .attr("opacity",.5)
								.attr("d",pathStringCL)
							svg1.append("path")
								.attr("stroke", colorD)
								.attr("stroke-width", 1)
								.attr("fill", colorD)
								// .attr("opacity",.5)
							.attr("d",pathStringDL)
					}
					drawLegendBCD([725,735],40);

					if(document.getElementById("datasetForm").value == "synthetic1" || document.getElementById("datasetForm").value == "synthetic2"){
						svg1.append("text")
							.text("B")
							.attr("y", 725)
							.attr("x", 763)
							.attr("font-size", 20)
							.attr("font-family", "sans-serif")
							.attr("fill", "black")
							.attr("stroke", "black");
						svg1.append("text")
							.text("C")
							.attr("y", 788)
							.attr("x", 735)
							.attr("font-size", 20)
							.attr("font-family", "sans-serif")
							.attr("fill", "black")
							.attr("stroke", "black");
						svg1.append("text")
							.text("D")
							.attr("y", 725)
							.attr("x", 670)
							.attr("font-size", 20)
							.attr("font-family", "sans-serif")
							.attr("fill", "black")
							.attr("stroke", "black");
					}
					else if(document.getElementById("datasetForm").value == "real1" || document.getElementById("datasetForm").value == "real2"){
						svg1.append("text")
							.text("Soil Moisture")
							.attr("y", 738)
							.attr("x", 733)
							.attr("font-size", 10)
							.attr("font-family", "sans-serif")
							.attr("fill", "black")
							.attr("stroke", "black");
						svg1.append("text")
							.text("Pressure")
							.attr("y", 785)
							.attr("x", 705)
							.attr("font-size", 10)
							.attr("font-family", "sans-serif")
							.attr("fill", "black")
							.attr("stroke", "black");
						svg1.append("text")
							.text("Temperature")
							.attr("y", 705)
							.attr("x", 660)
							.attr("font-size", 10)
							.attr("font-family", "sans-serif")
							.attr("fill", "black")
							.attr("stroke", "black");
					}
				}

				if(designCurrent == 4){
					var barX = [];
					var barY = [];
					var FixsidesforBCflag = 0;
					thicknessB = thickness/2;
					thicknessD = thickness/2;

					window.drawBarsTS = function(line, currentContour){
							lineLen = Math.sqrt(Math.pow((line[0][0]-line[1][0]), 2) + Math.pow((line[0][1]-line[1][1]), 2));
							// numCut = Math.floor(lineLen)*3;
							numCut = lineLen*3;
							line = line.map(function(x) { return [x[0] * mapRatio,x[1] * mapRatio]; })
							angle = Math.atan2(line[1][1] - line[0][1], line[1][0] - line[0][0]);

							for (x=0;x<=numCut+1;x++){
								// cutLine.push([(lineSlice[0][0]+lineSlice[1][0])*(i/(numCut+1)),(lineSlice[0][1]+lineSlice[1][1])*(i/(numCut+1))]);
								PointX = line[0][0]+(line[1][0]-line[0][0])*(x/(numCut+1));
								PointY = line[0][1]+(line[1][1]-line[0][1])*(x/(numCut+1));

								var lineStrokeWidth = thicknessD*getContourLabel(PointX/mapRatio, PointY/mapRatio, contourOutput_D);

								barX.push(PointX);
								barY.push(PointY);

								bval = getContourLabel(PointX/mapRatio, PointY/mapRatio, contourOutput_B);
								// console.log('Temp threshold at ', PointX, ' & ', PointY, 'is: ', bval);
								bdist = (thicknessB*bval)+2;
								cval = getContourLabel(PointX/mapRatio, PointY/mapRatio, contourOutput_C);
								// console.log('Soil threshold at ', PointX, ' & ', PointY, 'is: ', cval);

								PointX = Math.sin(angle) * (thicknessD/2) + PointX;
								PointY = -Math.cos(angle) * (thicknessD/2) + PointY;

								x1 = Math.sin(angle) * ((thicknessD/2)+bdist) + PointX;
								y1 = -Math.cos(angle) * ((thicknessD/2)+bdist) + PointY;

								svg1.append("path")
									 .attr("stroke", colorC(cval))
									 .attr("stroke-width", 3)
									 // .attr("stroke-linejoin", "mitter")
									.attr("d",lineGenerator([[PointX, PointY],[x1, y1]]))
							}
						}

					for (len=0;len<contourtoWorkon.length;len++){
						if (len == 0){
							FixsidesforBCflag = 1;
						}
						for(cor=0;cor<contourtoWorkon[len]["coordinates"].length;cor++){
							for(cornum=0;cornum<contourtoWorkon[len]["coordinates"][cor].length;cornum++){
								var simplified = contourtoWorkon[len]["coordinates"][cor][cornum];
								colorPrevious = 'white';
								TempCoordinatesStartPrevious = [[-1,-1],[-1,-1]];
								TempCoordinatesEndPrevious = [[-1,-1],[-1,-1]];
								currentLineStartColor = '';
								previousLineStartColor = '';
								currentLineEndColor = '';
								previousLineEndColor = '';
								contourStartTemp = [[-1,-1],[-1,-1]];
								// contourStartSoil = [-1,-1];
								if (Math.abs(polygonArea(Object.values(simplified))) > 20){
									for(y=0;y<simplified.length-1;y++){
										lineSlice = simplified.slice(y,y+2);
										lineLength = Math.sqrt(Math.pow((lineSlice[0][0]-lineSlice[1][0]), 2) + Math.pow((lineSlice[0][1]-lineSlice[1][1]), 2));
										// if (lineLength < latitude/1.5) {
										// 	drawBars(lineSlice, simplified);
										// }
										if ((lineSlice[0][0] >= vHeight-1 || lineSlice[0][0] <= 1 || lineSlice[0][1] >= vWidth-1 || lineSlice[0][1] <= 1) && (lineSlice[1][0] >= vWidth-1 || lineSlice[1][0] <= 1 || lineSlice[1][1] >= vHeight-1 || lineSlice[1][1] <= 1)) {
											drawlineSimple(lineSlice);
											continue;
										}
										drawBarsTS(lineSlice, simplified);
									}
								}
							}
						}
					}

					//draw contour lines with thickness based on D's value
					for (len=0;len<contourtoWorkon.length;len++){
						for(cor=0;cor<contourtoWorkon[len]["coordinates"].length;cor++){
							for(cornum=0;cornum<contourtoWorkon[len]["coordinates"][cor].length;cornum++){
								var simplified = contourtoWorkon[len]["coordinates"][cor][cornum];
								if (Math.abs(polygonArea(Object.values(simplified))) > 20){
									for(y=0;y<simplified.length-1;y++){
										lineSlice = simplified.slice(y,y+2);
										lineLength = Math.sqrt(Math.pow((lineSlice[0][0]-lineSlice[1][0]), 2) + Math.pow((lineSlice[0][1]-lineSlice[1][1]), 2));
										if ((lineSlice[0][0] >= vHeight-1 || lineSlice[0][0] <= 1 || lineSlice[0][1] >= vWidth-1 || lineSlice[0][1] <= 1) && (lineSlice[1][0] >= vWidth-1 || lineSlice[1][0] <= 1 || lineSlice[1][1] >= vHeight-1 || lineSlice[1][1] <= 1)) {
											drawlineSimple(lineSlice);
										}
										else{
											var numCut = Math.floor(lineLength);
											var cutLine = [lineSlice[0]];
											// console.log('Before Cut: ', lineSlice, ' / length: ', lineLength, ' / cuts needed: ', numCut);
											for (i=1;i<=numCut;i++){
												cutLine.push([lineSlice[0][0]+(lineSlice[1][0]-lineSlice[0][0])*(i/(numCut+1)),lineSlice[0][1]+(lineSlice[1][1]-lineSlice[0][1])*(i/(numCut+1))]);
											}
											cutLine.push(lineSlice[1]);
											// console.log('After cut: ', cutLine);
											for(jj=0;jj<cutLine.length-1;jj++){
												line2 = cutLine.slice(jj,jj+2);
												lineStrokeWidth = thicknessD*getContourLabel((line2[0][0]+line2[1][0])/2, (line2[0][1]+line2[1][1])/2, contourOutput_D);
												line2 = line2.map(function(x) { return [x[0] * mapRatio,x[1] * mapRatio]; })
												svg1.append("path")
													 .attr("stroke", colorD)
													 .attr("stroke-width", lineStrokeWidth)
													 // .attr("fill", colorD)
													 .attr("stroke-linecap", "round")
													.attr("d",lineGenerator(line2))
												// drawlineColorBlended(cutLine.slice(jj,jj+2), contourtoWorkon[len]["value"]);
											}
										}
									}
								}
							}
						}
					}

					svg1.append("rect")
							.attr("x", 703)
							.attr("y", 680)
							.attr("width", 91)
							.attr("height", 115)
							.attr("fill","#dddddd");

					window.drawLegendB = function(colorLegend){
											svg1.append("path")
												.attr("stroke", colorLegend)
												.attr("stroke-width", 1)
												.attr("fill", "none")
												.attr("d",'M'+ 710 + ',' + 697.5 + 'L'+ 790 + ',' + 690 +'L'+ 790 + ',' + 710 +'L'+ 710 + ',' + 705 + 'L' + 710 + ',' + 697.5 + 'L'+ 710 + ',' + 697.5)
							}
					drawLegendB("black");

					window.drawLegendC = function(lineLegend, thresArray){
								// drawlineSimple(lineLegend);
								lineout =  lineGenerator(lineLegend)
								svg1.append("path")
									 .attr("stroke", "black")
									 .attr("stroke-width", .5)
									 .attr("stroke-opacity",1)
									 // .attr("stroke-linejoin", "mitter")
									.attr("d",lineout)
								numCutt = 24;
								for (x=1;x<=numCutt;x++){
									PointX = lineLegend[0][0]+(lineLegend[1][0]-lineLegend[0][0])*(x/(numCutt+1));
									PointY = lineLegend[0][1]+(lineLegend[1][1]-lineLegend[0][1])*(x/(numCutt+1));
									// Ccolor = "red";
									// scolor = "green";
									angle = Math.atan2(lineLegend[1][1] - lineLegend[0][1], lineLegend[1][0] - lineLegend[0][0]);

									if(interval == 4){
										barLength = thresArray[Math.floor((x-1)/6)];
									}
									else if(interval == 6){
										barLength = thresArray[Math.floor((x-1)/4)];
									}
									else if(interval == 8){
										barLength = thresArray[Math.floor((x-1)/3)];
									}
									barcolor = colorC(barLength);

									// PointX = PointX * mapRatio;
									// PointY = PointY * mapRatio;

									demoy1 = -Math.cos(angle) * 10 + PointY;
									demoy2 = Math.cos(angle) * 10 + PointY;

									if (demoy1 < demoy2){
										x1 = Math.sin(angle) * 20 + PointX;
										y1 = -Math.cos(angle) * 20 + PointY;
										svg1.append("path")
											 .attr("stroke", barcolor)
											 .attr("stroke-width", 5)
											 .attr("fill", barcolor)
											 .attr("d",'M'+ x1 + ',' + y1 + 'L' + PointX + ',' + PointY)
									}
									else{
										x2 = -Math.sin(angle) * 20 + PointX;
										y2 = Math.cos(angle) * 20 + PointY;
										svg1.append("path")
												.attr("stroke", barcolor)
												.attr("stroke-width", 5)
												.attr("fill", barcolor)
												.attr("d",'M'+ x2 + ',' + y2 + 'L' + PointX + ',' + PointY)
									}
								}

							}
					drawLegendC([[712,748],[788,748]], thresholds_C);

					window.drawLegendD = function(line, thresArray, constLength, barcolor){
								// drawlineSimple(line);
								lineout =  lineGenerator(line)
								svg1.append("path")
									 .attr("stroke", "black")
									 .attr("stroke-width", .5)
									 .attr("stroke-opacity",1)
									 // .attr("stroke-linejoin", "mitter")
									.attr("d",lineout)
								numCut = 24;
								for (x=1;x<=numCut;x++){
									PointX = line[0][0]+(line[1][0]-line[0][0])*(x/(numCut+1));
									PointY = line[0][1]+(line[1][1]-line[0][1])*(x/(numCut+1));
									angle = Math.atan2(line[1][1] - line[0][1], line[1][0] - line[0][0]);

									if(interval == 4){
										barLength = thresArray[Math.floor((x-1)/6)];
									}
									else if(interval == 6){
										barLength = thresArray[Math.floor((x-1)/4)];
									}
									else if(interval == 8){
										barLength = thresArray[Math.floor((x-1)/3)];
									}

									// PointX = PointX * mapRatio;
									// PointY = PointY * mapRatio;

									demoy1 = -Math.cos(angle) * 10 + PointY;
									demoy2 = Math.cos(angle) * 10 + PointY;

									if (demoy1 < demoy2){
										x1 = Math.sin(angle) * barLength * constLength + PointX;
										y1 = -Math.cos(angle) * barLength * constLength + PointY;
										svg1.append("path")
											 .attr("stroke", barcolor)
											 .attr("stroke-width", 5)
											 .attr("d",'M'+ x1 + ',' + y1 + 'L' + PointX + ',' + PointY)
									}
									else{
										x2 = -Math.sin(angle) * barLength * constLength + PointX;
										y2 = Math.cos(angle) * barLength * constLength + PointY;
										svg1.append("path")
												.attr("stroke", barcolor)
												.attr("stroke-width", 5)
												.attr("d",'M'+ x2 + ',' + y2 + 'L' + PointX + ',' + PointY)
									}
								}
							}
					drawLegendD([[712,775],[788,775]], thresholds_D, thicknessD, colorD);

					if(document.getElementById("datasetForm").value == "synthetic1" || document.getElementById("datasetForm").value == "synthetic2"){
						svg1.append("text")
							.text("D")
							.attr("y", 792)
							.attr("x", 745)
							.attr("font-size", 20)
							.attr("font-family", "sans-serif")
							.attr("fill", "black")
							.attr("stroke", "black");

						svg1.append("text")
							.text("C")
							.attr("y", 765)
							.attr("x", 745)
							.attr("font-size", 20)
							.attr("font-family", "sans-serif")
							.attr("fill", "black")
							.attr("stroke", "black");

						svg1.append("text")
							.text("B")
							.attr("y", 725)
							.attr("x", 745)
							.attr("font-size", 20)
							.attr("font-family", "sans-serif")
							.attr("fill", "black")
							.attr("stroke", "black");
					}
					else if(document.getElementById("datasetForm").value == "real1" || document.getElementById("datasetForm").value == "real2"){
						svg1.append("text")
							.text("Temperature")
							.attr("y", 787)
							.attr("x", 723)
							.attr("font-size", 10)
							.attr("font-family", "sans-serif")
							.attr("fill", "black")
							.attr("stroke", "black");

						svg1.append("text")
							.text("Pressure")
							.attr("y", 759)
							.attr("x", 728)
							.attr("font-size", 10)
							.attr("font-family", "sans-serif")
							.attr("fill", "black")
							.attr("stroke", "black");

						svg1.append("text")
							.text("Soil Moisture")
							.attr("y", 720)
							.attr("x", 720)
							.attr("font-size", 10)
							.attr("font-family", "sans-serif")
							.attr("fill", "black")
							.attr("stroke", "black");
					}
				}

				if(designCurrent == 5){
					window.drawlineColorBlendSBS = function(line, threshval){
						var Bcolor = colorB(getContourLabel((line[0][0]+line[1][0])/2, (line[0][1]+line[1][1])/2, contourOutput_B));
						var Ccolor = colorC(getContourLabel((line[0][0]+line[1][0])/2, (line[0][1]+line[1][1])/2, contourOutput_C));
						var Dcolor = colorD(getContourLabel((line[0][0]+line[1][0])/2, (line[0][1]+line[1][1])/2, contourOutput_D));

						line = line.map(function(x) { return [x[0] * mapRatio,x[1] * mapRatio]; })
						// console.log(line);
						lineout =  lineGenerator(line)
						// console.log(lineout);
						svg2.append("path")
							 .attr("stroke", Bcolor)
							 .attr("stroke-width", thickness)
							 .attr("fill", Bcolor)
							 // .attr("stroke-linecap", "round")
							.attr("d",lineout)
						svg3.append("path")
							.attr("stroke", Ccolor)
							.attr("stroke-width", thickness)
							.attr("fill", Ccolor)
							// .attr("stroke-linecap", "round")
							.attr("d", lineout)
						svg4.append("path")
							.attr("stroke", Dcolor)
							.attr("stroke-width", thickness)
							.attr("fill", Dcolor)
							// .attr("stroke-linecap", "round")
							.attr("d", lineout)

					};

					for (len=0;len<contourtoWorkon.length;len++){
						for(cor=0;cor<contourtoWorkon[len]["coordinates"].length;cor++){
							for(cornum=0;cornum<contourtoWorkon[len]["coordinates"][cor].length;cornum++){
								var simplified = contourtoWorkon[len]["coordinates"][cor][cornum];
								if (Math.abs(polygonArea(Object.values(simplified))) > 20){
									for(y=0;y<simplified.length-1;y++){
										lineSlice = simplified.slice(y,y+2);
										lineLength = Math.sqrt(Math.pow((lineSlice[0][0]-lineSlice[1][0]), 2) + Math.pow((lineSlice[0][1]-lineSlice[1][1]), 2));
										if ((lineSlice[0][0] >= vHeight-1 || lineSlice[0][0] <= 1 || lineSlice[0][1] >= vWidth-1 || lineSlice[0][1] <= 1) && (lineSlice[1][0] >= vWidth-1 || lineSlice[1][0] <= 1 || lineSlice[1][1] >= vHeight-1 || lineSlice[1][1] <= 1)) {
											drawlineSimple(lineSlice);
										}
										else{
											var numCut = Math.floor(lineLength/(svg4.width/200));
											var cutLine = [lineSlice[0]];
											// console.log('Before Cut: ', lineSlice, ' / length: ', lineLength, ' / cuts needed: ', numCut);
											for (i=1;i<=numCut;i++){
												cutLine.push([lineSlice[0][0]+(lineSlice[1][0]-lineSlice[0][0])*(i/(numCut+1)),lineSlice[0][1]+(lineSlice[1][1]-lineSlice[0][1])*(i/(numCut+1))]);
											}
											cutLine.push(lineSlice[1]);
											// console.log('After cut: ', cutLine);
											for(jj=0;jj<cutLine.length-1;jj++){
												drawlineColorBlendSBS(cutLine.slice(jj,jj+2), contourtoWorkon[len]["value"]);
											}
										}
									}
								}
							}
						}
					}

					window.drawLegend_SBS = function(lineLegend, thresArray){
								drawlineSimple(lineLegend);
								numCutt = 24;
								for (x=1;x<=numCutt;x++){
									PointX = lineLegend[0][0]+(lineLegend[1][0]-lineLegend[0][0])*(x/(numCutt+1));
									PointY = lineLegend[0][1]+(lineLegend[1][1]-lineLegend[0][1])*(x/(numCutt+1));
									// Ccolor = "red";
									// scolor = "green";
									angle = Math.atan2(lineLegend[1][1] - lineLegend[0][1], lineLegend[1][0] - lineLegend[0][0]);

									if(interval == 4){
										barLength = thresArray[Math.floor((x-1)/6)];
									}
									else if(interval == 6){
										barLength = thresArray[Math.floor((x-1)/4)];
									}
									else if(interval == 8){
										barLength = thresArray[Math.floor((x-1)/3)];
									}
									barcolor = colorC(barLength);

									// PointX = PointX * mapRatio;
									// PointY = PointY * mapRatio;

									demoy1 = -Math.cos(angle) * 10 + PointY;
									demoy2 = Math.cos(angle) * 10 + PointY;

									if (demoy1 < demoy2){
										x1 = Math.sin(angle) * 20 + PointX;
										y1 = -Math.cos(angle) * 20 + PointY;
										svg2.append("path")
											 .attr("stroke", colorB(barLength))
											 .attr("stroke-width", 5)
											 .attr("fill", barcolor)
											 .attr("d",'M'+ x1 + ',' + y1 + 'L' + PointX + ',' + PointY)
										svg3.append("path")
											 .attr("stroke", colorC(barLength))
											 .attr("stroke-width", 5)
											 .attr("fill", barcolor)
											 .attr("d",'M'+ x1 + ',' + y1 + 'L' + PointX + ',' + PointY)
										svg4.append("path")
											 .attr("stroke", colorD(barLength))
											 .attr("stroke-width", 5)
											 .attr("fill", barcolor)
											 .attr("d",'M'+ x1 + ',' + y1 + 'L' + PointX + ',' + PointY)
									}
									else{
										x2 = -Math.sin(angle) * 20 + PointX;
										y2 = Math.cos(angle) * 20 + PointY;
										svg2.append("path")
											 .attr("stroke", colorB(barLength))
											 .attr("stroke-width", 5)
											 .attr("fill", barcolor)
											 .attr("d",'M'+ x2 + ',' + y2 + 'L' + PointX + ',' + PointY)
										svg3.append("path")
											 .attr("stroke", colorC(barLength))
											 .attr("stroke-width", 5)
											 .attr("fill", barcolor)
											 .attr("d",'M'+ x2 + ',' + y2 + 'L' + PointX + ',' + PointY)
										svg4.append("path")
											 .attr("stroke", colorD(barLength))
											 .attr("stroke-width", 5)
											 .attr("fill", barcolor)
											 .attr("d",'M'+ x2 + ',' + y2 + 'L' + PointX + ',' + PointY)
									}
								}
							}

					if(document.getElementById("datasetForm").value == "synthetic1" || document.getElementById("datasetForm").value == "synthetic2"){
						svg2.append("rect")
								.attr("x", 375)
								.attr("y", 425)
								.attr("width", 120)
								.attr("height", 30)
								.attr("fill","#dddddd");
						svg3.append("rect")
								.attr("x", 375)
								.attr("y", 425)
								.attr("width", 108)
								.attr("height", 30)
								.attr("fill","#dddddd");
						svg4.append("rect")
								.attr("x", 375)
								.attr("y", 425)
								.attr("width", 120)
								.attr("height", 30)
								.attr("fill","#dddddd");

						svg2.append("text")
								.text("B")
								.attr("y", 447)
								.attr("x", 380)
								.attr("font-size", 20)
								.attr("font-family", "sans-serif")
								.attr("fill", "black")
								.attr("stroke", "black");
						svg3.append("text")
								.text("C")
								.attr("y", 447)
								.attr("x", 380)
								.attr("font-size", 20)
								.attr("font-family", "sans-serif")
								.attr("fill", "black")
								.attr("stroke", "black");
						svg4.append("text")
								.text("D")
								.attr("y", 447)
								.attr("x", 380)
								.attr("font-size", 20)
								.attr("font-family", "sans-serif")
								.attr("fill", "black")
								.attr("stroke", "black");
					}
					else if(document.getElementById("datasetForm").value == "real1" || document.getElementById("datasetForm").value == "real2"){
						svg2.append("rect")
								.attr("x", 340)
								.attr("y", 425)
								.attr("width", 120)
								.attr("height", 30)
								.attr("fill","#dddddd");
						svg3.append("rect")
								.attr("x", 352)
								.attr("y", 425)
								.attr("width", 108)
								.attr("height", 30)
								.attr("fill","#dddddd");
						svg4.append("rect")
								.attr("x", 340)
								.attr("y", 425)
								.attr("width", 120)
								.attr("height", 30)
								.attr("fill","#dddddd");

						svg2.append("text")
								.text("Soil Moisture")
								.attr("y", 444)
								.attr("x", 345)
								.attr("font-size", 10)
								.attr("font-family", "sans-serif")
								.attr("fill", "black")
								.attr("stroke", "black");
						svg3.append("text")
								.text("Pressure")
								.attr("y", 444)
								.attr("x", 357)
								.attr("font-size", 10)
								.attr("font-family", "sans-serif")
								.attr("fill", "black")
								.attr("stroke", "black");
						svg4.append("text")
								.text("Temperature")
								.attr("y", 444)
								.attr("x", 345)
								.attr("font-size", 10)
								.attr("font-family", "sans-serif")
								.attr("fill", "black")
								.attr("stroke", "black");
					}

					drawLegend_SBS([[405,450],[455,450]], thresholds_A);

				}

				console.log(points);
				console.log(screen.width);
				console.log(designCurrent);

			});
		}

		// window.showtime = function() {
		// 	endTime = new Date();
		// 	timeDiff = endTime - startTime;
		// 	console.log('Time taken in ms: ', timeDiff);
		// }

		function mouseEvent() {
			// showtime();
			let mouse = d3.mouse(this);
			xMouse = parseInt(mouse[0]);
			yMouse = parseInt(mouse[1]);
			document.getElementById("mousePosition").innerHTML = "&nbsp&nbsp X: " + (xMouse / svgwidth * vWidth).toFixed(1) + "&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp    Y: " + (yMouse / svgwidth * vWidth).toFixed(1);
			labelA = getContourLabel(xMouse / mapRatio, yMouse / mapRatio, contourOutput_A);
			labelB = getContourLabel(xMouse / mapRatio, yMouse / mapRatio, contourOutput_B);
			labelC = getContourLabel(xMouse / mapRatio, yMouse / mapRatio, contourOutput_C);
			labelD = getContourLabel(xMouse / mapRatio, yMouse / mapRatio, contourOutput_D);
			document.getElementById("contourPosition").innerHTML = "&nbsp&nbsp A: " + labelA + "&nbsp&nbsp&nbsp&nbsp"+ "B: " + labelB+ "&nbsp&nbsp&nbsp&nbsp"+ "C: " + labelC + "&nbsp&nbsp&nbsp&nbsp"+ "D: " + labelC;
		}

		function mouseEventB() {
			let mouse = d3.mouse(this);
			xMouse = parseInt(mouse[0]);
			yMouse = parseInt(mouse[1]);
			document.getElementById("mousePosition").innerHTML = "&nbsp&nbsp X: " + (xMouse/mapRatio).toFixed(1) + "&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp     Y: " + (yMouse/mapRatio).toFixed(1);
			label = getContourLabel(xMouse/mapRatio, yMouse/mapRatio, contourOutput_B);
			document.getElementById("contourPosition").innerHTML = " &nbsp&nbsp B: " + "&nbsp&nbsp"+ label;
		}

		function mouseEventC() {
			let mouse = d3.mouse(this);
			xMouse = parseInt(mouse[0]);
			yMouse = parseInt(mouse[1]);
			document.getElementById("mousePosition").innerHTML = "&nbsp&nbsp X: " + (xMouse/svgwidth*vWidth).toFixed(1) + "&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp     Y: " + (yMouse/svgwidth*vWidth).toFixed(1);
			label = getContourLabel(xMouse/mapRatio, yMouse/mapRatio, contourOutput_C);
			document.getElementById("contourPosition").innerHTML = "&nbsp&nbsp C: " + "&nbsp&nbsp"+ label;
		}

		function mouseEventD() {
			let mouse = d3.mouse(this);
			xMouse = parseInt(mouse[0]);
			yMouse = parseInt(mouse[1]);
			document.getElementById("mousePosition").innerHTML = "&nbsp&nbsp X: " + (xMouse/svgwidth*vWidth).toFixed(1) + "&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp     Y: " + (yMouse/svgwidth*vWidth).toFixed(1);
			label = getContourLabel(xMouse/mapRatio, yMouse/mapRatio, contourOutput_D);
			document.getElementById("contourPosition").innerHTML = "&nbsp&nbsp D: " + "&nbsp&nbsp"+ label;
		}
	</script>

</body>

</html>
